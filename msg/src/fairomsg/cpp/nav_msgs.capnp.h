// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: nav_msgs.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 9001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "actionlib_msgs.capnp.h"
#include "geometry_msgs.capnp.h"
#include "std_msgs.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(a2ac7ce134b92ab5);
CAPNP_DECLARE_SCHEMA(bffc6aa2b598dbe5);
CAPNP_DECLARE_SCHEMA(905d1102a8035cf8);
CAPNP_DECLARE_SCHEMA(bf75d7b56f4261c9);
CAPNP_DECLARE_SCHEMA(c4cc55829ad52fb2);
CAPNP_DECLARE_SCHEMA(f57a1fe4984abed9);
CAPNP_DECLARE_SCHEMA(c0ba9939941783bb);
CAPNP_DECLARE_SCHEMA(c8b077ab0ba7f1ab);
CAPNP_DECLARE_SCHEMA(e83746019d1a2700);
CAPNP_DECLARE_SCHEMA(bdb63d4172a7e3bd);
CAPNP_DECLARE_SCHEMA(c3c4315f099df0c3);
CAPNP_DECLARE_SCHEMA(f17f4bc183b07e30);

}  // namespace schemas
}  // namespace capnp

namespace mrp {
namespace nav {

struct GetMapAction {
  GetMapAction() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a2ac7ce134b92ab5, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GetMapActionFeedback {
  GetMapActionFeedback() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bffc6aa2b598dbe5, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GetMapActionGoal {
  GetMapActionGoal() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(905d1102a8035cf8, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GetMapActionResult {
  GetMapActionResult() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bf75d7b56f4261c9, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GetMapFeedback {
  GetMapFeedback() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c4cc55829ad52fb2, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GetMapGoal {
  GetMapGoal() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f57a1fe4984abed9, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GetMapResult {
  GetMapResult() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c0ba9939941783bb, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GridCells {
  GridCells() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c8b077ab0ba7f1ab, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct MapMetaData {
  MapMetaData() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e83746019d1a2700, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct OccupancyGrid {
  OccupancyGrid() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bdb63d4172a7e3bd, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Odometry {
  Odometry() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c3c4315f099df0c3, 0, 4)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Path {
  Path() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f17f4bc183b07e30, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class GetMapAction::Reader {
public:
  typedef GetMapAction Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasActionGoal() const;
  inline  ::mrp::nav::GetMapActionGoal::Reader getActionGoal() const;

  inline bool hasActionResult() const;
  inline  ::mrp::nav::GetMapActionResult::Reader getActionResult() const;

  inline bool hasActionFeedback() const;
  inline  ::mrp::nav::GetMapActionFeedback::Reader getActionFeedback() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GetMapAction::Builder {
public:
  typedef GetMapAction Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasActionGoal();
  inline  ::mrp::nav::GetMapActionGoal::Builder getActionGoal();
  inline void setActionGoal( ::mrp::nav::GetMapActionGoal::Reader value);
  inline  ::mrp::nav::GetMapActionGoal::Builder initActionGoal();
  inline void adoptActionGoal(::capnp::Orphan< ::mrp::nav::GetMapActionGoal>&& value);
  inline ::capnp::Orphan< ::mrp::nav::GetMapActionGoal> disownActionGoal();

  inline bool hasActionResult();
  inline  ::mrp::nav::GetMapActionResult::Builder getActionResult();
  inline void setActionResult( ::mrp::nav::GetMapActionResult::Reader value);
  inline  ::mrp::nav::GetMapActionResult::Builder initActionResult();
  inline void adoptActionResult(::capnp::Orphan< ::mrp::nav::GetMapActionResult>&& value);
  inline ::capnp::Orphan< ::mrp::nav::GetMapActionResult> disownActionResult();

  inline bool hasActionFeedback();
  inline  ::mrp::nav::GetMapActionFeedback::Builder getActionFeedback();
  inline void setActionFeedback( ::mrp::nav::GetMapActionFeedback::Reader value);
  inline  ::mrp::nav::GetMapActionFeedback::Builder initActionFeedback();
  inline void adoptActionFeedback(::capnp::Orphan< ::mrp::nav::GetMapActionFeedback>&& value);
  inline ::capnp::Orphan< ::mrp::nav::GetMapActionFeedback> disownActionFeedback();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GetMapAction::Pipeline {
public:
  typedef GetMapAction Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::nav::GetMapActionGoal::Pipeline getActionGoal();
  inline  ::mrp::nav::GetMapActionResult::Pipeline getActionResult();
  inline  ::mrp::nav::GetMapActionFeedback::Pipeline getActionFeedback();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GetMapActionFeedback::Reader {
public:
  typedef GetMapActionFeedback Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::mrp::std::Header::Reader getHeader() const;

  inline bool hasStatus() const;
  inline  ::mrp::actionlib::GoalStatus::Reader getStatus() const;

  inline bool hasFeedback() const;
  inline  ::mrp::nav::GetMapFeedback::Reader getFeedback() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GetMapActionFeedback::Builder {
public:
  typedef GetMapActionFeedback Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::mrp::std::Header::Builder getHeader();
  inline void setHeader( ::mrp::std::Header::Reader value);
  inline  ::mrp::std::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::mrp::std::Header>&& value);
  inline ::capnp::Orphan< ::mrp::std::Header> disownHeader();

  inline bool hasStatus();
  inline  ::mrp::actionlib::GoalStatus::Builder getStatus();
  inline void setStatus( ::mrp::actionlib::GoalStatus::Reader value);
  inline  ::mrp::actionlib::GoalStatus::Builder initStatus();
  inline void adoptStatus(::capnp::Orphan< ::mrp::actionlib::GoalStatus>&& value);
  inline ::capnp::Orphan< ::mrp::actionlib::GoalStatus> disownStatus();

  inline bool hasFeedback();
  inline  ::mrp::nav::GetMapFeedback::Builder getFeedback();
  inline void setFeedback( ::mrp::nav::GetMapFeedback::Reader value);
  inline  ::mrp::nav::GetMapFeedback::Builder initFeedback();
  inline void adoptFeedback(::capnp::Orphan< ::mrp::nav::GetMapFeedback>&& value);
  inline ::capnp::Orphan< ::mrp::nav::GetMapFeedback> disownFeedback();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GetMapActionFeedback::Pipeline {
public:
  typedef GetMapActionFeedback Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::std::Header::Pipeline getHeader();
  inline  ::mrp::actionlib::GoalStatus::Pipeline getStatus();
  inline  ::mrp::nav::GetMapFeedback::Pipeline getFeedback();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GetMapActionGoal::Reader {
public:
  typedef GetMapActionGoal Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::mrp::std::Header::Reader getHeader() const;

  inline bool hasGoalId() const;
  inline  ::mrp::actionlib::GoalID::Reader getGoalId() const;

  inline bool hasGoal() const;
  inline  ::mrp::nav::GetMapGoal::Reader getGoal() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GetMapActionGoal::Builder {
public:
  typedef GetMapActionGoal Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::mrp::std::Header::Builder getHeader();
  inline void setHeader( ::mrp::std::Header::Reader value);
  inline  ::mrp::std::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::mrp::std::Header>&& value);
  inline ::capnp::Orphan< ::mrp::std::Header> disownHeader();

  inline bool hasGoalId();
  inline  ::mrp::actionlib::GoalID::Builder getGoalId();
  inline void setGoalId( ::mrp::actionlib::GoalID::Reader value);
  inline  ::mrp::actionlib::GoalID::Builder initGoalId();
  inline void adoptGoalId(::capnp::Orphan< ::mrp::actionlib::GoalID>&& value);
  inline ::capnp::Orphan< ::mrp::actionlib::GoalID> disownGoalId();

  inline bool hasGoal();
  inline  ::mrp::nav::GetMapGoal::Builder getGoal();
  inline void setGoal( ::mrp::nav::GetMapGoal::Reader value);
  inline  ::mrp::nav::GetMapGoal::Builder initGoal();
  inline void adoptGoal(::capnp::Orphan< ::mrp::nav::GetMapGoal>&& value);
  inline ::capnp::Orphan< ::mrp::nav::GetMapGoal> disownGoal();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GetMapActionGoal::Pipeline {
public:
  typedef GetMapActionGoal Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::std::Header::Pipeline getHeader();
  inline  ::mrp::actionlib::GoalID::Pipeline getGoalId();
  inline  ::mrp::nav::GetMapGoal::Pipeline getGoal();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GetMapActionResult::Reader {
public:
  typedef GetMapActionResult Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::mrp::std::Header::Reader getHeader() const;

  inline bool hasStatus() const;
  inline  ::mrp::actionlib::GoalStatus::Reader getStatus() const;

  inline bool hasResult() const;
  inline  ::mrp::nav::GetMapResult::Reader getResult() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GetMapActionResult::Builder {
public:
  typedef GetMapActionResult Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::mrp::std::Header::Builder getHeader();
  inline void setHeader( ::mrp::std::Header::Reader value);
  inline  ::mrp::std::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::mrp::std::Header>&& value);
  inline ::capnp::Orphan< ::mrp::std::Header> disownHeader();

  inline bool hasStatus();
  inline  ::mrp::actionlib::GoalStatus::Builder getStatus();
  inline void setStatus( ::mrp::actionlib::GoalStatus::Reader value);
  inline  ::mrp::actionlib::GoalStatus::Builder initStatus();
  inline void adoptStatus(::capnp::Orphan< ::mrp::actionlib::GoalStatus>&& value);
  inline ::capnp::Orphan< ::mrp::actionlib::GoalStatus> disownStatus();

  inline bool hasResult();
  inline  ::mrp::nav::GetMapResult::Builder getResult();
  inline void setResult( ::mrp::nav::GetMapResult::Reader value);
  inline  ::mrp::nav::GetMapResult::Builder initResult();
  inline void adoptResult(::capnp::Orphan< ::mrp::nav::GetMapResult>&& value);
  inline ::capnp::Orphan< ::mrp::nav::GetMapResult> disownResult();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GetMapActionResult::Pipeline {
public:
  typedef GetMapActionResult Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::std::Header::Pipeline getHeader();
  inline  ::mrp::actionlib::GoalStatus::Pipeline getStatus();
  inline  ::mrp::nav::GetMapResult::Pipeline getResult();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GetMapFeedback::Reader {
public:
  typedef GetMapFeedback Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GetMapFeedback::Builder {
public:
  typedef GetMapFeedback Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GetMapFeedback::Pipeline {
public:
  typedef GetMapFeedback Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GetMapGoal::Reader {
public:
  typedef GetMapGoal Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GetMapGoal::Builder {
public:
  typedef GetMapGoal Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GetMapGoal::Pipeline {
public:
  typedef GetMapGoal Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GetMapResult::Reader {
public:
  typedef GetMapResult Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasMap() const;
  inline  ::mrp::nav::OccupancyGrid::Reader getMap() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GetMapResult::Builder {
public:
  typedef GetMapResult Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMap();
  inline  ::mrp::nav::OccupancyGrid::Builder getMap();
  inline void setMap( ::mrp::nav::OccupancyGrid::Reader value);
  inline  ::mrp::nav::OccupancyGrid::Builder initMap();
  inline void adoptMap(::capnp::Orphan< ::mrp::nav::OccupancyGrid>&& value);
  inline ::capnp::Orphan< ::mrp::nav::OccupancyGrid> disownMap();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GetMapResult::Pipeline {
public:
  typedef GetMapResult Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::nav::OccupancyGrid::Pipeline getMap();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GridCells::Reader {
public:
  typedef GridCells Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::mrp::std::Header::Reader getHeader() const;

  inline float getCellWidth() const;

  inline float getCellHeight() const;

  inline bool hasCells() const;
  inline  ::capnp::List< ::mrp::geometry::Point,  ::capnp::Kind::STRUCT>::Reader getCells() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GridCells::Builder {
public:
  typedef GridCells Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::mrp::std::Header::Builder getHeader();
  inline void setHeader( ::mrp::std::Header::Reader value);
  inline  ::mrp::std::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::mrp::std::Header>&& value);
  inline ::capnp::Orphan< ::mrp::std::Header> disownHeader();

  inline float getCellWidth();
  inline void setCellWidth(float value);

  inline float getCellHeight();
  inline void setCellHeight(float value);

  inline bool hasCells();
  inline  ::capnp::List< ::mrp::geometry::Point,  ::capnp::Kind::STRUCT>::Builder getCells();
  inline void setCells( ::capnp::List< ::mrp::geometry::Point,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mrp::geometry::Point,  ::capnp::Kind::STRUCT>::Builder initCells(unsigned int size);
  inline void adoptCells(::capnp::Orphan< ::capnp::List< ::mrp::geometry::Point,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mrp::geometry::Point,  ::capnp::Kind::STRUCT>> disownCells();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GridCells::Pipeline {
public:
  typedef GridCells Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::std::Header::Pipeline getHeader();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class MapMetaData::Reader {
public:
  typedef MapMetaData Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasMapLoadTime() const;
  inline  ::mrp::std::Time::Reader getMapLoadTime() const;

  inline float getResolution() const;

  inline  ::uint32_t getWidth() const;

  inline  ::uint32_t getHeight() const;

  inline bool hasOrigin() const;
  inline  ::mrp::geometry::Pose::Reader getOrigin() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class MapMetaData::Builder {
public:
  typedef MapMetaData Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasMapLoadTime();
  inline  ::mrp::std::Time::Builder getMapLoadTime();
  inline void setMapLoadTime( ::mrp::std::Time::Reader value);
  inline  ::mrp::std::Time::Builder initMapLoadTime();
  inline void adoptMapLoadTime(::capnp::Orphan< ::mrp::std::Time>&& value);
  inline ::capnp::Orphan< ::mrp::std::Time> disownMapLoadTime();

  inline float getResolution();
  inline void setResolution(float value);

  inline  ::uint32_t getWidth();
  inline void setWidth( ::uint32_t value);

  inline  ::uint32_t getHeight();
  inline void setHeight( ::uint32_t value);

  inline bool hasOrigin();
  inline  ::mrp::geometry::Pose::Builder getOrigin();
  inline void setOrigin( ::mrp::geometry::Pose::Reader value);
  inline  ::mrp::geometry::Pose::Builder initOrigin();
  inline void adoptOrigin(::capnp::Orphan< ::mrp::geometry::Pose>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::Pose> disownOrigin();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class MapMetaData::Pipeline {
public:
  typedef MapMetaData Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::std::Time::Pipeline getMapLoadTime();
  inline  ::mrp::geometry::Pose::Pipeline getOrigin();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class OccupancyGrid::Reader {
public:
  typedef OccupancyGrid Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::mrp::std::Header::Reader getHeader() const;

  inline bool hasInfo() const;
  inline  ::mrp::nav::MapMetaData::Reader getInfo() const;

  inline bool hasData() const;
  inline  ::capnp::Data::Reader getData() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class OccupancyGrid::Builder {
public:
  typedef OccupancyGrid Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::mrp::std::Header::Builder getHeader();
  inline void setHeader( ::mrp::std::Header::Reader value);
  inline  ::mrp::std::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::mrp::std::Header>&& value);
  inline ::capnp::Orphan< ::mrp::std::Header> disownHeader();

  inline bool hasInfo();
  inline  ::mrp::nav::MapMetaData::Builder getInfo();
  inline void setInfo( ::mrp::nav::MapMetaData::Reader value);
  inline  ::mrp::nav::MapMetaData::Builder initInfo();
  inline void adoptInfo(::capnp::Orphan< ::mrp::nav::MapMetaData>&& value);
  inline ::capnp::Orphan< ::mrp::nav::MapMetaData> disownInfo();

  inline bool hasData();
  inline  ::capnp::Data::Builder getData();
  inline void setData( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initData(unsigned int size);
  inline void adoptData(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownData();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class OccupancyGrid::Pipeline {
public:
  typedef OccupancyGrid Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::std::Header::Pipeline getHeader();
  inline  ::mrp::nav::MapMetaData::Pipeline getInfo();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Odometry::Reader {
public:
  typedef Odometry Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::mrp::std::Header::Reader getHeader() const;

  inline bool hasChildFrameId() const;
  inline  ::capnp::Text::Reader getChildFrameId() const;

  inline bool hasPose() const;
  inline  ::mrp::geometry::PoseWithCovariance::Reader getPose() const;

  inline bool hasTwist() const;
  inline  ::mrp::geometry::TwistWithCovariance::Reader getTwist() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Odometry::Builder {
public:
  typedef Odometry Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::mrp::std::Header::Builder getHeader();
  inline void setHeader( ::mrp::std::Header::Reader value);
  inline  ::mrp::std::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::mrp::std::Header>&& value);
  inline ::capnp::Orphan< ::mrp::std::Header> disownHeader();

  inline bool hasChildFrameId();
  inline  ::capnp::Text::Builder getChildFrameId();
  inline void setChildFrameId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initChildFrameId(unsigned int size);
  inline void adoptChildFrameId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownChildFrameId();

  inline bool hasPose();
  inline  ::mrp::geometry::PoseWithCovariance::Builder getPose();
  inline void setPose( ::mrp::geometry::PoseWithCovariance::Reader value);
  inline  ::mrp::geometry::PoseWithCovariance::Builder initPose();
  inline void adoptPose(::capnp::Orphan< ::mrp::geometry::PoseWithCovariance>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::PoseWithCovariance> disownPose();

  inline bool hasTwist();
  inline  ::mrp::geometry::TwistWithCovariance::Builder getTwist();
  inline void setTwist( ::mrp::geometry::TwistWithCovariance::Reader value);
  inline  ::mrp::geometry::TwistWithCovariance::Builder initTwist();
  inline void adoptTwist(::capnp::Orphan< ::mrp::geometry::TwistWithCovariance>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::TwistWithCovariance> disownTwist();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Odometry::Pipeline {
public:
  typedef Odometry Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::std::Header::Pipeline getHeader();
  inline  ::mrp::geometry::PoseWithCovariance::Pipeline getPose();
  inline  ::mrp::geometry::TwistWithCovariance::Pipeline getTwist();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Path::Reader {
public:
  typedef Path Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::mrp::std::Header::Reader getHeader() const;

  inline bool hasPoses() const;
  inline  ::capnp::List< ::mrp::geometry::PoseStamped,  ::capnp::Kind::STRUCT>::Reader getPoses() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Path::Builder {
public:
  typedef Path Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::mrp::std::Header::Builder getHeader();
  inline void setHeader( ::mrp::std::Header::Reader value);
  inline  ::mrp::std::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::mrp::std::Header>&& value);
  inline ::capnp::Orphan< ::mrp::std::Header> disownHeader();

  inline bool hasPoses();
  inline  ::capnp::List< ::mrp::geometry::PoseStamped,  ::capnp::Kind::STRUCT>::Builder getPoses();
  inline void setPoses( ::capnp::List< ::mrp::geometry::PoseStamped,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mrp::geometry::PoseStamped,  ::capnp::Kind::STRUCT>::Builder initPoses(unsigned int size);
  inline void adoptPoses(::capnp::Orphan< ::capnp::List< ::mrp::geometry::PoseStamped,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mrp::geometry::PoseStamped,  ::capnp::Kind::STRUCT>> disownPoses();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Path::Pipeline {
public:
  typedef Path Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::std::Header::Pipeline getHeader();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline bool GetMapAction::Reader::hasActionGoal() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool GetMapAction::Builder::hasActionGoal() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::nav::GetMapActionGoal::Reader GetMapAction::Reader::getActionGoal() const {
  return ::capnp::_::PointerHelpers< ::mrp::nav::GetMapActionGoal>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::nav::GetMapActionGoal::Builder GetMapAction::Builder::getActionGoal() {
  return ::capnp::_::PointerHelpers< ::mrp::nav::GetMapActionGoal>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::nav::GetMapActionGoal::Pipeline GetMapAction::Pipeline::getActionGoal() {
  return  ::mrp::nav::GetMapActionGoal::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void GetMapAction::Builder::setActionGoal( ::mrp::nav::GetMapActionGoal::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::nav::GetMapActionGoal>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::nav::GetMapActionGoal::Builder GetMapAction::Builder::initActionGoal() {
  return ::capnp::_::PointerHelpers< ::mrp::nav::GetMapActionGoal>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void GetMapAction::Builder::adoptActionGoal(
    ::capnp::Orphan< ::mrp::nav::GetMapActionGoal>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::nav::GetMapActionGoal>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::nav::GetMapActionGoal> GetMapAction::Builder::disownActionGoal() {
  return ::capnp::_::PointerHelpers< ::mrp::nav::GetMapActionGoal>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool GetMapAction::Reader::hasActionResult() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool GetMapAction::Builder::hasActionResult() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::nav::GetMapActionResult::Reader GetMapAction::Reader::getActionResult() const {
  return ::capnp::_::PointerHelpers< ::mrp::nav::GetMapActionResult>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mrp::nav::GetMapActionResult::Builder GetMapAction::Builder::getActionResult() {
  return ::capnp::_::PointerHelpers< ::mrp::nav::GetMapActionResult>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::nav::GetMapActionResult::Pipeline GetMapAction::Pipeline::getActionResult() {
  return  ::mrp::nav::GetMapActionResult::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void GetMapAction::Builder::setActionResult( ::mrp::nav::GetMapActionResult::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::nav::GetMapActionResult>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mrp::nav::GetMapActionResult::Builder GetMapAction::Builder::initActionResult() {
  return ::capnp::_::PointerHelpers< ::mrp::nav::GetMapActionResult>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void GetMapAction::Builder::adoptActionResult(
    ::capnp::Orphan< ::mrp::nav::GetMapActionResult>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::nav::GetMapActionResult>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::nav::GetMapActionResult> GetMapAction::Builder::disownActionResult() {
  return ::capnp::_::PointerHelpers< ::mrp::nav::GetMapActionResult>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool GetMapAction::Reader::hasActionFeedback() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool GetMapAction::Builder::hasActionFeedback() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::nav::GetMapActionFeedback::Reader GetMapAction::Reader::getActionFeedback() const {
  return ::capnp::_::PointerHelpers< ::mrp::nav::GetMapActionFeedback>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::mrp::nav::GetMapActionFeedback::Builder GetMapAction::Builder::getActionFeedback() {
  return ::capnp::_::PointerHelpers< ::mrp::nav::GetMapActionFeedback>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::nav::GetMapActionFeedback::Pipeline GetMapAction::Pipeline::getActionFeedback() {
  return  ::mrp::nav::GetMapActionFeedback::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void GetMapAction::Builder::setActionFeedback( ::mrp::nav::GetMapActionFeedback::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::nav::GetMapActionFeedback>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::mrp::nav::GetMapActionFeedback::Builder GetMapAction::Builder::initActionFeedback() {
  return ::capnp::_::PointerHelpers< ::mrp::nav::GetMapActionFeedback>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void GetMapAction::Builder::adoptActionFeedback(
    ::capnp::Orphan< ::mrp::nav::GetMapActionFeedback>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::nav::GetMapActionFeedback>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::nav::GetMapActionFeedback> GetMapAction::Builder::disownActionFeedback() {
  return ::capnp::_::PointerHelpers< ::mrp::nav::GetMapActionFeedback>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool GetMapActionFeedback::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool GetMapActionFeedback::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::std::Header::Reader GetMapActionFeedback::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::std::Header::Builder GetMapActionFeedback::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::std::Header::Pipeline GetMapActionFeedback::Pipeline::getHeader() {
  return  ::mrp::std::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void GetMapActionFeedback::Builder::setHeader( ::mrp::std::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::std::Header::Builder GetMapActionFeedback::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void GetMapActionFeedback::Builder::adoptHeader(
    ::capnp::Orphan< ::mrp::std::Header>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::std::Header> GetMapActionFeedback::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool GetMapActionFeedback::Reader::hasStatus() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool GetMapActionFeedback::Builder::hasStatus() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::actionlib::GoalStatus::Reader GetMapActionFeedback::Reader::getStatus() const {
  return ::capnp::_::PointerHelpers< ::mrp::actionlib::GoalStatus>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mrp::actionlib::GoalStatus::Builder GetMapActionFeedback::Builder::getStatus() {
  return ::capnp::_::PointerHelpers< ::mrp::actionlib::GoalStatus>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::actionlib::GoalStatus::Pipeline GetMapActionFeedback::Pipeline::getStatus() {
  return  ::mrp::actionlib::GoalStatus::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void GetMapActionFeedback::Builder::setStatus( ::mrp::actionlib::GoalStatus::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::actionlib::GoalStatus>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mrp::actionlib::GoalStatus::Builder GetMapActionFeedback::Builder::initStatus() {
  return ::capnp::_::PointerHelpers< ::mrp::actionlib::GoalStatus>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void GetMapActionFeedback::Builder::adoptStatus(
    ::capnp::Orphan< ::mrp::actionlib::GoalStatus>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::actionlib::GoalStatus>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::actionlib::GoalStatus> GetMapActionFeedback::Builder::disownStatus() {
  return ::capnp::_::PointerHelpers< ::mrp::actionlib::GoalStatus>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool GetMapActionFeedback::Reader::hasFeedback() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool GetMapActionFeedback::Builder::hasFeedback() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::nav::GetMapFeedback::Reader GetMapActionFeedback::Reader::getFeedback() const {
  return ::capnp::_::PointerHelpers< ::mrp::nav::GetMapFeedback>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::mrp::nav::GetMapFeedback::Builder GetMapActionFeedback::Builder::getFeedback() {
  return ::capnp::_::PointerHelpers< ::mrp::nav::GetMapFeedback>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::nav::GetMapFeedback::Pipeline GetMapActionFeedback::Pipeline::getFeedback() {
  return  ::mrp::nav::GetMapFeedback::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void GetMapActionFeedback::Builder::setFeedback( ::mrp::nav::GetMapFeedback::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::nav::GetMapFeedback>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::mrp::nav::GetMapFeedback::Builder GetMapActionFeedback::Builder::initFeedback() {
  return ::capnp::_::PointerHelpers< ::mrp::nav::GetMapFeedback>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void GetMapActionFeedback::Builder::adoptFeedback(
    ::capnp::Orphan< ::mrp::nav::GetMapFeedback>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::nav::GetMapFeedback>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::nav::GetMapFeedback> GetMapActionFeedback::Builder::disownFeedback() {
  return ::capnp::_::PointerHelpers< ::mrp::nav::GetMapFeedback>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool GetMapActionGoal::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool GetMapActionGoal::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::std::Header::Reader GetMapActionGoal::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::std::Header::Builder GetMapActionGoal::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::std::Header::Pipeline GetMapActionGoal::Pipeline::getHeader() {
  return  ::mrp::std::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void GetMapActionGoal::Builder::setHeader( ::mrp::std::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::std::Header::Builder GetMapActionGoal::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void GetMapActionGoal::Builder::adoptHeader(
    ::capnp::Orphan< ::mrp::std::Header>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::std::Header> GetMapActionGoal::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool GetMapActionGoal::Reader::hasGoalId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool GetMapActionGoal::Builder::hasGoalId() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::actionlib::GoalID::Reader GetMapActionGoal::Reader::getGoalId() const {
  return ::capnp::_::PointerHelpers< ::mrp::actionlib::GoalID>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mrp::actionlib::GoalID::Builder GetMapActionGoal::Builder::getGoalId() {
  return ::capnp::_::PointerHelpers< ::mrp::actionlib::GoalID>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::actionlib::GoalID::Pipeline GetMapActionGoal::Pipeline::getGoalId() {
  return  ::mrp::actionlib::GoalID::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void GetMapActionGoal::Builder::setGoalId( ::mrp::actionlib::GoalID::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::actionlib::GoalID>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mrp::actionlib::GoalID::Builder GetMapActionGoal::Builder::initGoalId() {
  return ::capnp::_::PointerHelpers< ::mrp::actionlib::GoalID>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void GetMapActionGoal::Builder::adoptGoalId(
    ::capnp::Orphan< ::mrp::actionlib::GoalID>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::actionlib::GoalID>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::actionlib::GoalID> GetMapActionGoal::Builder::disownGoalId() {
  return ::capnp::_::PointerHelpers< ::mrp::actionlib::GoalID>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool GetMapActionGoal::Reader::hasGoal() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool GetMapActionGoal::Builder::hasGoal() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::nav::GetMapGoal::Reader GetMapActionGoal::Reader::getGoal() const {
  return ::capnp::_::PointerHelpers< ::mrp::nav::GetMapGoal>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::mrp::nav::GetMapGoal::Builder GetMapActionGoal::Builder::getGoal() {
  return ::capnp::_::PointerHelpers< ::mrp::nav::GetMapGoal>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::nav::GetMapGoal::Pipeline GetMapActionGoal::Pipeline::getGoal() {
  return  ::mrp::nav::GetMapGoal::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void GetMapActionGoal::Builder::setGoal( ::mrp::nav::GetMapGoal::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::nav::GetMapGoal>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::mrp::nav::GetMapGoal::Builder GetMapActionGoal::Builder::initGoal() {
  return ::capnp::_::PointerHelpers< ::mrp::nav::GetMapGoal>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void GetMapActionGoal::Builder::adoptGoal(
    ::capnp::Orphan< ::mrp::nav::GetMapGoal>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::nav::GetMapGoal>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::nav::GetMapGoal> GetMapActionGoal::Builder::disownGoal() {
  return ::capnp::_::PointerHelpers< ::mrp::nav::GetMapGoal>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool GetMapActionResult::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool GetMapActionResult::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::std::Header::Reader GetMapActionResult::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::std::Header::Builder GetMapActionResult::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::std::Header::Pipeline GetMapActionResult::Pipeline::getHeader() {
  return  ::mrp::std::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void GetMapActionResult::Builder::setHeader( ::mrp::std::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::std::Header::Builder GetMapActionResult::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void GetMapActionResult::Builder::adoptHeader(
    ::capnp::Orphan< ::mrp::std::Header>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::std::Header> GetMapActionResult::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool GetMapActionResult::Reader::hasStatus() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool GetMapActionResult::Builder::hasStatus() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::actionlib::GoalStatus::Reader GetMapActionResult::Reader::getStatus() const {
  return ::capnp::_::PointerHelpers< ::mrp::actionlib::GoalStatus>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mrp::actionlib::GoalStatus::Builder GetMapActionResult::Builder::getStatus() {
  return ::capnp::_::PointerHelpers< ::mrp::actionlib::GoalStatus>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::actionlib::GoalStatus::Pipeline GetMapActionResult::Pipeline::getStatus() {
  return  ::mrp::actionlib::GoalStatus::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void GetMapActionResult::Builder::setStatus( ::mrp::actionlib::GoalStatus::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::actionlib::GoalStatus>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mrp::actionlib::GoalStatus::Builder GetMapActionResult::Builder::initStatus() {
  return ::capnp::_::PointerHelpers< ::mrp::actionlib::GoalStatus>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void GetMapActionResult::Builder::adoptStatus(
    ::capnp::Orphan< ::mrp::actionlib::GoalStatus>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::actionlib::GoalStatus>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::actionlib::GoalStatus> GetMapActionResult::Builder::disownStatus() {
  return ::capnp::_::PointerHelpers< ::mrp::actionlib::GoalStatus>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool GetMapActionResult::Reader::hasResult() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool GetMapActionResult::Builder::hasResult() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::nav::GetMapResult::Reader GetMapActionResult::Reader::getResult() const {
  return ::capnp::_::PointerHelpers< ::mrp::nav::GetMapResult>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::mrp::nav::GetMapResult::Builder GetMapActionResult::Builder::getResult() {
  return ::capnp::_::PointerHelpers< ::mrp::nav::GetMapResult>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::nav::GetMapResult::Pipeline GetMapActionResult::Pipeline::getResult() {
  return  ::mrp::nav::GetMapResult::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void GetMapActionResult::Builder::setResult( ::mrp::nav::GetMapResult::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::nav::GetMapResult>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::mrp::nav::GetMapResult::Builder GetMapActionResult::Builder::initResult() {
  return ::capnp::_::PointerHelpers< ::mrp::nav::GetMapResult>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void GetMapActionResult::Builder::adoptResult(
    ::capnp::Orphan< ::mrp::nav::GetMapResult>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::nav::GetMapResult>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::nav::GetMapResult> GetMapActionResult::Builder::disownResult() {
  return ::capnp::_::PointerHelpers< ::mrp::nav::GetMapResult>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool GetMapResult::Reader::hasMap() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool GetMapResult::Builder::hasMap() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::nav::OccupancyGrid::Reader GetMapResult::Reader::getMap() const {
  return ::capnp::_::PointerHelpers< ::mrp::nav::OccupancyGrid>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::nav::OccupancyGrid::Builder GetMapResult::Builder::getMap() {
  return ::capnp::_::PointerHelpers< ::mrp::nav::OccupancyGrid>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::nav::OccupancyGrid::Pipeline GetMapResult::Pipeline::getMap() {
  return  ::mrp::nav::OccupancyGrid::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void GetMapResult::Builder::setMap( ::mrp::nav::OccupancyGrid::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::nav::OccupancyGrid>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::nav::OccupancyGrid::Builder GetMapResult::Builder::initMap() {
  return ::capnp::_::PointerHelpers< ::mrp::nav::OccupancyGrid>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void GetMapResult::Builder::adoptMap(
    ::capnp::Orphan< ::mrp::nav::OccupancyGrid>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::nav::OccupancyGrid>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::nav::OccupancyGrid> GetMapResult::Builder::disownMap() {
  return ::capnp::_::PointerHelpers< ::mrp::nav::OccupancyGrid>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool GridCells::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool GridCells::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::std::Header::Reader GridCells::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::std::Header::Builder GridCells::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::std::Header::Pipeline GridCells::Pipeline::getHeader() {
  return  ::mrp::std::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void GridCells::Builder::setHeader( ::mrp::std::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::std::Header::Builder GridCells::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void GridCells::Builder::adoptHeader(
    ::capnp::Orphan< ::mrp::std::Header>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::std::Header> GridCells::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float GridCells::Reader::getCellWidth() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float GridCells::Builder::getCellWidth() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void GridCells::Builder::setCellWidth(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float GridCells::Reader::getCellHeight() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float GridCells::Builder::getCellHeight() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void GridCells::Builder::setCellHeight(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool GridCells::Reader::hasCells() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool GridCells::Builder::hasCells() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mrp::geometry::Point,  ::capnp::Kind::STRUCT>::Reader GridCells::Reader::getCells() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mrp::geometry::Point,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mrp::geometry::Point,  ::capnp::Kind::STRUCT>::Builder GridCells::Builder::getCells() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mrp::geometry::Point,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void GridCells::Builder::setCells( ::capnp::List< ::mrp::geometry::Point,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mrp::geometry::Point,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mrp::geometry::Point,  ::capnp::Kind::STRUCT>::Builder GridCells::Builder::initCells(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mrp::geometry::Point,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void GridCells::Builder::adoptCells(
    ::capnp::Orphan< ::capnp::List< ::mrp::geometry::Point,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mrp::geometry::Point,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mrp::geometry::Point,  ::capnp::Kind::STRUCT>> GridCells::Builder::disownCells() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mrp::geometry::Point,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool MapMetaData::Reader::hasMapLoadTime() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool MapMetaData::Builder::hasMapLoadTime() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::std::Time::Reader MapMetaData::Reader::getMapLoadTime() const {
  return ::capnp::_::PointerHelpers< ::mrp::std::Time>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::std::Time::Builder MapMetaData::Builder::getMapLoadTime() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Time>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::std::Time::Pipeline MapMetaData::Pipeline::getMapLoadTime() {
  return  ::mrp::std::Time::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void MapMetaData::Builder::setMapLoadTime( ::mrp::std::Time::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Time>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::std::Time::Builder MapMetaData::Builder::initMapLoadTime() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Time>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void MapMetaData::Builder::adoptMapLoadTime(
    ::capnp::Orphan< ::mrp::std::Time>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Time>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::std::Time> MapMetaData::Builder::disownMapLoadTime() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Time>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float MapMetaData::Reader::getResolution() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float MapMetaData::Builder::getResolution() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void MapMetaData::Builder::setResolution(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t MapMetaData::Reader::getWidth() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t MapMetaData::Builder::getWidth() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void MapMetaData::Builder::setWidth( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t MapMetaData::Reader::getHeight() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t MapMetaData::Builder::getHeight() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void MapMetaData::Builder::setHeight( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool MapMetaData::Reader::hasOrigin() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool MapMetaData::Builder::hasOrigin() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::Pose::Reader MapMetaData::Reader::getOrigin() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Pose>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::Pose::Builder MapMetaData::Builder::getOrigin() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Pose>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::Pose::Pipeline MapMetaData::Pipeline::getOrigin() {
  return  ::mrp::geometry::Pose::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void MapMetaData::Builder::setOrigin( ::mrp::geometry::Pose::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Pose>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::Pose::Builder MapMetaData::Builder::initOrigin() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Pose>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void MapMetaData::Builder::adoptOrigin(
    ::capnp::Orphan< ::mrp::geometry::Pose>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Pose>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::Pose> MapMetaData::Builder::disownOrigin() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Pose>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool OccupancyGrid::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool OccupancyGrid::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::std::Header::Reader OccupancyGrid::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::std::Header::Builder OccupancyGrid::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::std::Header::Pipeline OccupancyGrid::Pipeline::getHeader() {
  return  ::mrp::std::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void OccupancyGrid::Builder::setHeader( ::mrp::std::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::std::Header::Builder OccupancyGrid::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void OccupancyGrid::Builder::adoptHeader(
    ::capnp::Orphan< ::mrp::std::Header>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::std::Header> OccupancyGrid::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool OccupancyGrid::Reader::hasInfo() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool OccupancyGrid::Builder::hasInfo() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::nav::MapMetaData::Reader OccupancyGrid::Reader::getInfo() const {
  return ::capnp::_::PointerHelpers< ::mrp::nav::MapMetaData>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mrp::nav::MapMetaData::Builder OccupancyGrid::Builder::getInfo() {
  return ::capnp::_::PointerHelpers< ::mrp::nav::MapMetaData>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::nav::MapMetaData::Pipeline OccupancyGrid::Pipeline::getInfo() {
  return  ::mrp::nav::MapMetaData::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void OccupancyGrid::Builder::setInfo( ::mrp::nav::MapMetaData::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::nav::MapMetaData>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mrp::nav::MapMetaData::Builder OccupancyGrid::Builder::initInfo() {
  return ::capnp::_::PointerHelpers< ::mrp::nav::MapMetaData>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void OccupancyGrid::Builder::adoptInfo(
    ::capnp::Orphan< ::mrp::nav::MapMetaData>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::nav::MapMetaData>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::nav::MapMetaData> OccupancyGrid::Builder::disownInfo() {
  return ::capnp::_::PointerHelpers< ::mrp::nav::MapMetaData>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool OccupancyGrid::Reader::hasData() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool OccupancyGrid::Builder::hasData() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader OccupancyGrid::Reader::getData() const {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder OccupancyGrid::Builder::getData() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void OccupancyGrid::Builder::setData( ::capnp::Data::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder OccupancyGrid::Builder::initData(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void OccupancyGrid::Builder::adoptData(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> OccupancyGrid::Builder::disownData() {
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Odometry::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Odometry::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::std::Header::Reader Odometry::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::std::Header::Builder Odometry::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::std::Header::Pipeline Odometry::Pipeline::getHeader() {
  return  ::mrp::std::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Odometry::Builder::setHeader( ::mrp::std::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::std::Header::Builder Odometry::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Odometry::Builder::adoptHeader(
    ::capnp::Orphan< ::mrp::std::Header>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::std::Header> Odometry::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Odometry::Reader::hasChildFrameId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Odometry::Builder::hasChildFrameId() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Odometry::Reader::getChildFrameId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Odometry::Builder::getChildFrameId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Odometry::Builder::setChildFrameId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Odometry::Builder::initChildFrameId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Odometry::Builder::adoptChildFrameId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Odometry::Builder::disownChildFrameId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Odometry::Reader::hasPose() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Odometry::Builder::hasPose() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::PoseWithCovariance::Reader Odometry::Reader::getPose() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::PoseWithCovariance>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::PoseWithCovariance::Builder Odometry::Builder::getPose() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::PoseWithCovariance>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::PoseWithCovariance::Pipeline Odometry::Pipeline::getPose() {
  return  ::mrp::geometry::PoseWithCovariance::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Odometry::Builder::setPose( ::mrp::geometry::PoseWithCovariance::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::PoseWithCovariance>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::PoseWithCovariance::Builder Odometry::Builder::initPose() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::PoseWithCovariance>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Odometry::Builder::adoptPose(
    ::capnp::Orphan< ::mrp::geometry::PoseWithCovariance>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::PoseWithCovariance>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::PoseWithCovariance> Odometry::Builder::disownPose() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::PoseWithCovariance>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Odometry::Reader::hasTwist() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Odometry::Builder::hasTwist() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::TwistWithCovariance::Reader Odometry::Reader::getTwist() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::TwistWithCovariance>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::TwistWithCovariance::Builder Odometry::Builder::getTwist() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::TwistWithCovariance>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::TwistWithCovariance::Pipeline Odometry::Pipeline::getTwist() {
  return  ::mrp::geometry::TwistWithCovariance::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void Odometry::Builder::setTwist( ::mrp::geometry::TwistWithCovariance::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::TwistWithCovariance>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::TwistWithCovariance::Builder Odometry::Builder::initTwist() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::TwistWithCovariance>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Odometry::Builder::adoptTwist(
    ::capnp::Orphan< ::mrp::geometry::TwistWithCovariance>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::TwistWithCovariance>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::TwistWithCovariance> Odometry::Builder::disownTwist() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::TwistWithCovariance>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Path::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Path::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::std::Header::Reader Path::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::std::Header::Builder Path::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::std::Header::Pipeline Path::Pipeline::getHeader() {
  return  ::mrp::std::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Path::Builder::setHeader( ::mrp::std::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::std::Header::Builder Path::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Path::Builder::adoptHeader(
    ::capnp::Orphan< ::mrp::std::Header>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::std::Header> Path::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Path::Reader::hasPoses() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Path::Builder::hasPoses() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mrp::geometry::PoseStamped,  ::capnp::Kind::STRUCT>::Reader Path::Reader::getPoses() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mrp::geometry::PoseStamped,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mrp::geometry::PoseStamped,  ::capnp::Kind::STRUCT>::Builder Path::Builder::getPoses() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mrp::geometry::PoseStamped,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Path::Builder::setPoses( ::capnp::List< ::mrp::geometry::PoseStamped,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mrp::geometry::PoseStamped,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mrp::geometry::PoseStamped,  ::capnp::Kind::STRUCT>::Builder Path::Builder::initPoses(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mrp::geometry::PoseStamped,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Path::Builder::adoptPoses(
    ::capnp::Orphan< ::capnp::List< ::mrp::geometry::PoseStamped,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mrp::geometry::PoseStamped,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mrp::geometry::PoseStamped,  ::capnp::Kind::STRUCT>> Path::Builder::disownPoses() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mrp::geometry::PoseStamped,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

}  // namespace
}  // namespace

CAPNP_END_HEADER

