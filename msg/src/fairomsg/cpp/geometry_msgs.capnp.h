// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: geometry_msgs.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 9001
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif

#include "std_msgs.capnp.h"

CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(c85214e2b79237b1);
CAPNP_DECLARE_SCHEMA(8806d80e8e8c4d40);
CAPNP_DECLARE_SCHEMA(a51c6b3c512f5eee);
CAPNP_DECLARE_SCHEMA(fd8fa84434c29dd4);
CAPNP_DECLARE_SCHEMA(85066bc334c104d8);
CAPNP_DECLARE_SCHEMA(c0a33a5089a90236);
CAPNP_DECLARE_SCHEMA(ebab599af84d3b44);
CAPNP_DECLARE_SCHEMA(bd17305162f7a3dd);
CAPNP_DECLARE_SCHEMA(bb3a4e3eb6109801);
CAPNP_DECLARE_SCHEMA(ac7d25eb0068cd89);
CAPNP_DECLARE_SCHEMA(90ebe6e3a8d4af38);
CAPNP_DECLARE_SCHEMA(aaf6c5a3bec98ba8);
CAPNP_DECLARE_SCHEMA(e5f936f25dcdb4a0);
CAPNP_DECLARE_SCHEMA(a7f72661fcb193b7);
CAPNP_DECLARE_SCHEMA(9e7f144eb85fe85e);
CAPNP_DECLARE_SCHEMA(fa182984d85f3156);
CAPNP_DECLARE_SCHEMA(90e5c0f787726f80);
CAPNP_DECLARE_SCHEMA(af118a4cffb70464);
CAPNP_DECLARE_SCHEMA(e714439bda2b8906);
CAPNP_DECLARE_SCHEMA(cf223f32b610adbc);
CAPNP_DECLARE_SCHEMA(dfcb9692fa102dfa);
CAPNP_DECLARE_SCHEMA(e3eff53945d605c5);
CAPNP_DECLARE_SCHEMA(ec932d063971839b);
CAPNP_DECLARE_SCHEMA(f3d733cd6fbc271d);
CAPNP_DECLARE_SCHEMA(a7564fb9bc29b220);
CAPNP_DECLARE_SCHEMA(89d716bb34f0209a);
CAPNP_DECLARE_SCHEMA(f1b4c19528330dc3);
CAPNP_DECLARE_SCHEMA(81c2ac67ce6ef5ac);
CAPNP_DECLARE_SCHEMA(92557f02c3e04d9a);

}  // namespace schemas
}  // namespace capnp

namespace mrp {
namespace geometry {

struct Accel {
  Accel() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c85214e2b79237b1, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AccelStamped {
  AccelStamped() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(8806d80e8e8c4d40, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AccelWithCovariance {
  AccelWithCovariance() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a51c6b3c512f5eee, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct AccelWithCovarianceStamped {
  AccelWithCovarianceStamped() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fd8fa84434c29dd4, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Inertia {
  Inertia() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(85066bc334c104d8, 7, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct InertiaStamped {
  InertiaStamped() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c0a33a5089a90236, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Point {
  Point() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ebab599af84d3b44, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Point32 {
  Point32() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bd17305162f7a3dd, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PointStamped {
  PointStamped() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bb3a4e3eb6109801, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Polygon {
  Polygon() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ac7d25eb0068cd89, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PolygonStamped {
  PolygonStamped() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(90ebe6e3a8d4af38, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Pose {
  Pose() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(aaf6c5a3bec98ba8, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Pose2D {
  Pose2D() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e5f936f25dcdb4a0, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PoseArray {
  PoseArray() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a7f72661fcb193b7, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PoseStamped {
  PoseStamped() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9e7f144eb85fe85e, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PoseWithCovariance {
  PoseWithCovariance() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fa182984d85f3156, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct PoseWithCovarianceStamped {
  PoseWithCovarianceStamped() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(90e5c0f787726f80, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Quaternion {
  Quaternion() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(af118a4cffb70464, 4, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct QuaternionStamped {
  QuaternionStamped() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e714439bda2b8906, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Transform {
  Transform() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(cf223f32b610adbc, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TransformStamped {
  TransformStamped() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dfcb9692fa102dfa, 0, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Twist {
  Twist() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e3eff53945d605c5, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TwistStamped {
  TwistStamped() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ec932d063971839b, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TwistWithCovariance {
  TwistWithCovariance() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f3d733cd6fbc271d, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct TwistWithCovarianceStamped {
  TwistWithCovarianceStamped() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a7564fb9bc29b220, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Vector3 {
  Vector3() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(89d716bb34f0209a, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Vector3Stamped {
  Vector3Stamped() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f1b4c19528330dc3, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Wrench {
  Wrench() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(81c2ac67ce6ef5ac, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct WrenchStamped {
  WrenchStamped() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(92557f02c3e04d9a, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Accel::Reader {
public:
  typedef Accel Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLinear() const;
  inline  ::mrp::geometry::Vector3::Reader getLinear() const;

  inline bool hasAngular() const;
  inline  ::mrp::geometry::Vector3::Reader getAngular() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Accel::Builder {
public:
  typedef Accel Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLinear();
  inline  ::mrp::geometry::Vector3::Builder getLinear();
  inline void setLinear( ::mrp::geometry::Vector3::Reader value);
  inline  ::mrp::geometry::Vector3::Builder initLinear();
  inline void adoptLinear(::capnp::Orphan< ::mrp::geometry::Vector3>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::Vector3> disownLinear();

  inline bool hasAngular();
  inline  ::mrp::geometry::Vector3::Builder getAngular();
  inline void setAngular( ::mrp::geometry::Vector3::Reader value);
  inline  ::mrp::geometry::Vector3::Builder initAngular();
  inline void adoptAngular(::capnp::Orphan< ::mrp::geometry::Vector3>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::Vector3> disownAngular();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Accel::Pipeline {
public:
  typedef Accel Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::geometry::Vector3::Pipeline getLinear();
  inline  ::mrp::geometry::Vector3::Pipeline getAngular();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AccelStamped::Reader {
public:
  typedef AccelStamped Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::mrp::std::Header::Reader getHeader() const;

  inline bool hasAccel() const;
  inline  ::mrp::geometry::Accel::Reader getAccel() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AccelStamped::Builder {
public:
  typedef AccelStamped Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::mrp::std::Header::Builder getHeader();
  inline void setHeader( ::mrp::std::Header::Reader value);
  inline  ::mrp::std::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::mrp::std::Header>&& value);
  inline ::capnp::Orphan< ::mrp::std::Header> disownHeader();

  inline bool hasAccel();
  inline  ::mrp::geometry::Accel::Builder getAccel();
  inline void setAccel( ::mrp::geometry::Accel::Reader value);
  inline  ::mrp::geometry::Accel::Builder initAccel();
  inline void adoptAccel(::capnp::Orphan< ::mrp::geometry::Accel>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::Accel> disownAccel();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AccelStamped::Pipeline {
public:
  typedef AccelStamped Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::std::Header::Pipeline getHeader();
  inline  ::mrp::geometry::Accel::Pipeline getAccel();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AccelWithCovariance::Reader {
public:
  typedef AccelWithCovariance Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasAccel() const;
  inline  ::mrp::geometry::Accel::Reader getAccel() const;

  inline bool hasCovariance() const;
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader getCovariance() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AccelWithCovariance::Builder {
public:
  typedef AccelWithCovariance Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasAccel();
  inline  ::mrp::geometry::Accel::Builder getAccel();
  inline void setAccel( ::mrp::geometry::Accel::Reader value);
  inline  ::mrp::geometry::Accel::Builder initAccel();
  inline void adoptAccel(::capnp::Orphan< ::mrp::geometry::Accel>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::Accel> disownAccel();

  inline bool hasCovariance();
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder getCovariance();
  inline void setCovariance( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setCovariance(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder initCovariance(unsigned int size);
  inline void adoptCovariance(::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> disownCovariance();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AccelWithCovariance::Pipeline {
public:
  typedef AccelWithCovariance Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::geometry::Accel::Pipeline getAccel();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class AccelWithCovarianceStamped::Reader {
public:
  typedef AccelWithCovarianceStamped Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::mrp::std::Header::Reader getHeader() const;

  inline bool hasAccel() const;
  inline  ::mrp::geometry::AccelWithCovariance::Reader getAccel() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class AccelWithCovarianceStamped::Builder {
public:
  typedef AccelWithCovarianceStamped Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::mrp::std::Header::Builder getHeader();
  inline void setHeader( ::mrp::std::Header::Reader value);
  inline  ::mrp::std::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::mrp::std::Header>&& value);
  inline ::capnp::Orphan< ::mrp::std::Header> disownHeader();

  inline bool hasAccel();
  inline  ::mrp::geometry::AccelWithCovariance::Builder getAccel();
  inline void setAccel( ::mrp::geometry::AccelWithCovariance::Reader value);
  inline  ::mrp::geometry::AccelWithCovariance::Builder initAccel();
  inline void adoptAccel(::capnp::Orphan< ::mrp::geometry::AccelWithCovariance>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::AccelWithCovariance> disownAccel();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class AccelWithCovarianceStamped::Pipeline {
public:
  typedef AccelWithCovarianceStamped Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::std::Header::Pipeline getHeader();
  inline  ::mrp::geometry::AccelWithCovariance::Pipeline getAccel();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Inertia::Reader {
public:
  typedef Inertia Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getM() const;

  inline bool hasCom() const;
  inline  ::mrp::geometry::Vector3::Reader getCom() const;

  inline double getIxx() const;

  inline double getIxy() const;

  inline double getIxz() const;

  inline double getIyy() const;

  inline double getIyz() const;

  inline double getIzz() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Inertia::Builder {
public:
  typedef Inertia Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getM();
  inline void setM(double value);

  inline bool hasCom();
  inline  ::mrp::geometry::Vector3::Builder getCom();
  inline void setCom( ::mrp::geometry::Vector3::Reader value);
  inline  ::mrp::geometry::Vector3::Builder initCom();
  inline void adoptCom(::capnp::Orphan< ::mrp::geometry::Vector3>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::Vector3> disownCom();

  inline double getIxx();
  inline void setIxx(double value);

  inline double getIxy();
  inline void setIxy(double value);

  inline double getIxz();
  inline void setIxz(double value);

  inline double getIyy();
  inline void setIyy(double value);

  inline double getIyz();
  inline void setIyz(double value);

  inline double getIzz();
  inline void setIzz(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Inertia::Pipeline {
public:
  typedef Inertia Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::geometry::Vector3::Pipeline getCom();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class InertiaStamped::Reader {
public:
  typedef InertiaStamped Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::mrp::std::Header::Reader getHeader() const;

  inline bool hasInertia() const;
  inline  ::mrp::geometry::Inertia::Reader getInertia() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class InertiaStamped::Builder {
public:
  typedef InertiaStamped Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::mrp::std::Header::Builder getHeader();
  inline void setHeader( ::mrp::std::Header::Reader value);
  inline  ::mrp::std::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::mrp::std::Header>&& value);
  inline ::capnp::Orphan< ::mrp::std::Header> disownHeader();

  inline bool hasInertia();
  inline  ::mrp::geometry::Inertia::Builder getInertia();
  inline void setInertia( ::mrp::geometry::Inertia::Reader value);
  inline  ::mrp::geometry::Inertia::Builder initInertia();
  inline void adoptInertia(::capnp::Orphan< ::mrp::geometry::Inertia>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::Inertia> disownInertia();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class InertiaStamped::Pipeline {
public:
  typedef InertiaStamped Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::std::Header::Pipeline getHeader();
  inline  ::mrp::geometry::Inertia::Pipeline getInertia();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Point::Reader {
public:
  typedef Point Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getX() const;

  inline double getY() const;

  inline double getZ() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Point::Builder {
public:
  typedef Point Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getX();
  inline void setX(double value);

  inline double getY();
  inline void setY(double value);

  inline double getZ();
  inline void setZ(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Point::Pipeline {
public:
  typedef Point Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Point32::Reader {
public:
  typedef Point32 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getX() const;

  inline float getY() const;

  inline float getZ() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Point32::Builder {
public:
  typedef Point32 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getX();
  inline void setX(float value);

  inline float getY();
  inline void setY(float value);

  inline float getZ();
  inline void setZ(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Point32::Pipeline {
public:
  typedef Point32 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PointStamped::Reader {
public:
  typedef PointStamped Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::mrp::std::Header::Reader getHeader() const;

  inline bool hasPoint() const;
  inline  ::mrp::geometry::Point::Reader getPoint() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PointStamped::Builder {
public:
  typedef PointStamped Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::mrp::std::Header::Builder getHeader();
  inline void setHeader( ::mrp::std::Header::Reader value);
  inline  ::mrp::std::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::mrp::std::Header>&& value);
  inline ::capnp::Orphan< ::mrp::std::Header> disownHeader();

  inline bool hasPoint();
  inline  ::mrp::geometry::Point::Builder getPoint();
  inline void setPoint( ::mrp::geometry::Point::Reader value);
  inline  ::mrp::geometry::Point::Builder initPoint();
  inline void adoptPoint(::capnp::Orphan< ::mrp::geometry::Point>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::Point> disownPoint();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PointStamped::Pipeline {
public:
  typedef PointStamped Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::std::Header::Pipeline getHeader();
  inline  ::mrp::geometry::Point::Pipeline getPoint();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Polygon::Reader {
public:
  typedef Polygon Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPoints() const;
  inline  ::capnp::List< ::mrp::geometry::Point32,  ::capnp::Kind::STRUCT>::Reader getPoints() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Polygon::Builder {
public:
  typedef Polygon Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPoints();
  inline  ::capnp::List< ::mrp::geometry::Point32,  ::capnp::Kind::STRUCT>::Builder getPoints();
  inline void setPoints( ::capnp::List< ::mrp::geometry::Point32,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mrp::geometry::Point32,  ::capnp::Kind::STRUCT>::Builder initPoints(unsigned int size);
  inline void adoptPoints(::capnp::Orphan< ::capnp::List< ::mrp::geometry::Point32,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mrp::geometry::Point32,  ::capnp::Kind::STRUCT>> disownPoints();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Polygon::Pipeline {
public:
  typedef Polygon Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PolygonStamped::Reader {
public:
  typedef PolygonStamped Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::mrp::std::Header::Reader getHeader() const;

  inline bool hasPolygon() const;
  inline  ::mrp::geometry::Polygon::Reader getPolygon() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PolygonStamped::Builder {
public:
  typedef PolygonStamped Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::mrp::std::Header::Builder getHeader();
  inline void setHeader( ::mrp::std::Header::Reader value);
  inline  ::mrp::std::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::mrp::std::Header>&& value);
  inline ::capnp::Orphan< ::mrp::std::Header> disownHeader();

  inline bool hasPolygon();
  inline  ::mrp::geometry::Polygon::Builder getPolygon();
  inline void setPolygon( ::mrp::geometry::Polygon::Reader value);
  inline  ::mrp::geometry::Polygon::Builder initPolygon();
  inline void adoptPolygon(::capnp::Orphan< ::mrp::geometry::Polygon>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::Polygon> disownPolygon();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PolygonStamped::Pipeline {
public:
  typedef PolygonStamped Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::std::Header::Pipeline getHeader();
  inline  ::mrp::geometry::Polygon::Pipeline getPolygon();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Pose::Reader {
public:
  typedef Pose Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPosition() const;
  inline  ::mrp::geometry::Point::Reader getPosition() const;

  inline bool hasOrientation() const;
  inline  ::mrp::geometry::Quaternion::Reader getOrientation() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Pose::Builder {
public:
  typedef Pose Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPosition();
  inline  ::mrp::geometry::Point::Builder getPosition();
  inline void setPosition( ::mrp::geometry::Point::Reader value);
  inline  ::mrp::geometry::Point::Builder initPosition();
  inline void adoptPosition(::capnp::Orphan< ::mrp::geometry::Point>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::Point> disownPosition();

  inline bool hasOrientation();
  inline  ::mrp::geometry::Quaternion::Builder getOrientation();
  inline void setOrientation( ::mrp::geometry::Quaternion::Reader value);
  inline  ::mrp::geometry::Quaternion::Builder initOrientation();
  inline void adoptOrientation(::capnp::Orphan< ::mrp::geometry::Quaternion>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::Quaternion> disownOrientation();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Pose::Pipeline {
public:
  typedef Pose Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::geometry::Point::Pipeline getPosition();
  inline  ::mrp::geometry::Quaternion::Pipeline getOrientation();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Pose2D::Reader {
public:
  typedef Pose2D Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getX() const;

  inline double getY() const;

  inline double getTheta() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Pose2D::Builder {
public:
  typedef Pose2D Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getX();
  inline void setX(double value);

  inline double getY();
  inline void setY(double value);

  inline double getTheta();
  inline void setTheta(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Pose2D::Pipeline {
public:
  typedef Pose2D Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PoseArray::Reader {
public:
  typedef PoseArray Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::mrp::std::Header::Reader getHeader() const;

  inline bool hasPoses() const;
  inline  ::capnp::List< ::mrp::geometry::Pose,  ::capnp::Kind::STRUCT>::Reader getPoses() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PoseArray::Builder {
public:
  typedef PoseArray Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::mrp::std::Header::Builder getHeader();
  inline void setHeader( ::mrp::std::Header::Reader value);
  inline  ::mrp::std::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::mrp::std::Header>&& value);
  inline ::capnp::Orphan< ::mrp::std::Header> disownHeader();

  inline bool hasPoses();
  inline  ::capnp::List< ::mrp::geometry::Pose,  ::capnp::Kind::STRUCT>::Builder getPoses();
  inline void setPoses( ::capnp::List< ::mrp::geometry::Pose,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::mrp::geometry::Pose,  ::capnp::Kind::STRUCT>::Builder initPoses(unsigned int size);
  inline void adoptPoses(::capnp::Orphan< ::capnp::List< ::mrp::geometry::Pose,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::mrp::geometry::Pose,  ::capnp::Kind::STRUCT>> disownPoses();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PoseArray::Pipeline {
public:
  typedef PoseArray Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::std::Header::Pipeline getHeader();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PoseStamped::Reader {
public:
  typedef PoseStamped Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::mrp::std::Header::Reader getHeader() const;

  inline bool hasPose() const;
  inline  ::mrp::geometry::Pose::Reader getPose() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PoseStamped::Builder {
public:
  typedef PoseStamped Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::mrp::std::Header::Builder getHeader();
  inline void setHeader( ::mrp::std::Header::Reader value);
  inline  ::mrp::std::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::mrp::std::Header>&& value);
  inline ::capnp::Orphan< ::mrp::std::Header> disownHeader();

  inline bool hasPose();
  inline  ::mrp::geometry::Pose::Builder getPose();
  inline void setPose( ::mrp::geometry::Pose::Reader value);
  inline  ::mrp::geometry::Pose::Builder initPose();
  inline void adoptPose(::capnp::Orphan< ::mrp::geometry::Pose>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::Pose> disownPose();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PoseStamped::Pipeline {
public:
  typedef PoseStamped Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::std::Header::Pipeline getHeader();
  inline  ::mrp::geometry::Pose::Pipeline getPose();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PoseWithCovariance::Reader {
public:
  typedef PoseWithCovariance Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPose() const;
  inline  ::mrp::geometry::Pose::Reader getPose() const;

  inline bool hasCovariance() const;
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader getCovariance() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PoseWithCovariance::Builder {
public:
  typedef PoseWithCovariance Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPose();
  inline  ::mrp::geometry::Pose::Builder getPose();
  inline void setPose( ::mrp::geometry::Pose::Reader value);
  inline  ::mrp::geometry::Pose::Builder initPose();
  inline void adoptPose(::capnp::Orphan< ::mrp::geometry::Pose>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::Pose> disownPose();

  inline bool hasCovariance();
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder getCovariance();
  inline void setCovariance( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setCovariance(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder initCovariance(unsigned int size);
  inline void adoptCovariance(::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> disownCovariance();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PoseWithCovariance::Pipeline {
public:
  typedef PoseWithCovariance Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::geometry::Pose::Pipeline getPose();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class PoseWithCovarianceStamped::Reader {
public:
  typedef PoseWithCovarianceStamped Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::mrp::std::Header::Reader getHeader() const;

  inline bool hasPose() const;
  inline  ::mrp::geometry::PoseWithCovariance::Reader getPose() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PoseWithCovarianceStamped::Builder {
public:
  typedef PoseWithCovarianceStamped Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::mrp::std::Header::Builder getHeader();
  inline void setHeader( ::mrp::std::Header::Reader value);
  inline  ::mrp::std::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::mrp::std::Header>&& value);
  inline ::capnp::Orphan< ::mrp::std::Header> disownHeader();

  inline bool hasPose();
  inline  ::mrp::geometry::PoseWithCovariance::Builder getPose();
  inline void setPose( ::mrp::geometry::PoseWithCovariance::Reader value);
  inline  ::mrp::geometry::PoseWithCovariance::Builder initPose();
  inline void adoptPose(::capnp::Orphan< ::mrp::geometry::PoseWithCovariance>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::PoseWithCovariance> disownPose();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PoseWithCovarianceStamped::Pipeline {
public:
  typedef PoseWithCovarianceStamped Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::std::Header::Pipeline getHeader();
  inline  ::mrp::geometry::PoseWithCovariance::Pipeline getPose();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Quaternion::Reader {
public:
  typedef Quaternion Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getX() const;

  inline double getY() const;

  inline double getZ() const;

  inline double getW() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Quaternion::Builder {
public:
  typedef Quaternion Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getX();
  inline void setX(double value);

  inline double getY();
  inline void setY(double value);

  inline double getZ();
  inline void setZ(double value);

  inline double getW();
  inline void setW(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Quaternion::Pipeline {
public:
  typedef Quaternion Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class QuaternionStamped::Reader {
public:
  typedef QuaternionStamped Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::mrp::std::Header::Reader getHeader() const;

  inline bool hasQuaternion() const;
  inline  ::mrp::geometry::Quaternion::Reader getQuaternion() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class QuaternionStamped::Builder {
public:
  typedef QuaternionStamped Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::mrp::std::Header::Builder getHeader();
  inline void setHeader( ::mrp::std::Header::Reader value);
  inline  ::mrp::std::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::mrp::std::Header>&& value);
  inline ::capnp::Orphan< ::mrp::std::Header> disownHeader();

  inline bool hasQuaternion();
  inline  ::mrp::geometry::Quaternion::Builder getQuaternion();
  inline void setQuaternion( ::mrp::geometry::Quaternion::Reader value);
  inline  ::mrp::geometry::Quaternion::Builder initQuaternion();
  inline void adoptQuaternion(::capnp::Orphan< ::mrp::geometry::Quaternion>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::Quaternion> disownQuaternion();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class QuaternionStamped::Pipeline {
public:
  typedef QuaternionStamped Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::std::Header::Pipeline getHeader();
  inline  ::mrp::geometry::Quaternion::Pipeline getQuaternion();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Transform::Reader {
public:
  typedef Transform Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTranslation() const;
  inline  ::mrp::geometry::Vector3::Reader getTranslation() const;

  inline bool hasRotation() const;
  inline  ::mrp::geometry::Quaternion::Reader getRotation() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Transform::Builder {
public:
  typedef Transform Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTranslation();
  inline  ::mrp::geometry::Vector3::Builder getTranslation();
  inline void setTranslation( ::mrp::geometry::Vector3::Reader value);
  inline  ::mrp::geometry::Vector3::Builder initTranslation();
  inline void adoptTranslation(::capnp::Orphan< ::mrp::geometry::Vector3>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::Vector3> disownTranslation();

  inline bool hasRotation();
  inline  ::mrp::geometry::Quaternion::Builder getRotation();
  inline void setRotation( ::mrp::geometry::Quaternion::Reader value);
  inline  ::mrp::geometry::Quaternion::Builder initRotation();
  inline void adoptRotation(::capnp::Orphan< ::mrp::geometry::Quaternion>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::Quaternion> disownRotation();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Transform::Pipeline {
public:
  typedef Transform Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::geometry::Vector3::Pipeline getTranslation();
  inline  ::mrp::geometry::Quaternion::Pipeline getRotation();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TransformStamped::Reader {
public:
  typedef TransformStamped Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::mrp::std::Header::Reader getHeader() const;

  inline bool hasChildFrameId() const;
  inline  ::capnp::Text::Reader getChildFrameId() const;

  inline bool hasTransform() const;
  inline  ::mrp::geometry::Transform::Reader getTransform() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TransformStamped::Builder {
public:
  typedef TransformStamped Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::mrp::std::Header::Builder getHeader();
  inline void setHeader( ::mrp::std::Header::Reader value);
  inline  ::mrp::std::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::mrp::std::Header>&& value);
  inline ::capnp::Orphan< ::mrp::std::Header> disownHeader();

  inline bool hasChildFrameId();
  inline  ::capnp::Text::Builder getChildFrameId();
  inline void setChildFrameId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initChildFrameId(unsigned int size);
  inline void adoptChildFrameId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownChildFrameId();

  inline bool hasTransform();
  inline  ::mrp::geometry::Transform::Builder getTransform();
  inline void setTransform( ::mrp::geometry::Transform::Reader value);
  inline  ::mrp::geometry::Transform::Builder initTransform();
  inline void adoptTransform(::capnp::Orphan< ::mrp::geometry::Transform>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::Transform> disownTransform();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TransformStamped::Pipeline {
public:
  typedef TransformStamped Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::std::Header::Pipeline getHeader();
  inline  ::mrp::geometry::Transform::Pipeline getTransform();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Twist::Reader {
public:
  typedef Twist Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLinear() const;
  inline  ::mrp::geometry::Vector3::Reader getLinear() const;

  inline bool hasAngular() const;
  inline  ::mrp::geometry::Vector3::Reader getAngular() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Twist::Builder {
public:
  typedef Twist Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLinear();
  inline  ::mrp::geometry::Vector3::Builder getLinear();
  inline void setLinear( ::mrp::geometry::Vector3::Reader value);
  inline  ::mrp::geometry::Vector3::Builder initLinear();
  inline void adoptLinear(::capnp::Orphan< ::mrp::geometry::Vector3>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::Vector3> disownLinear();

  inline bool hasAngular();
  inline  ::mrp::geometry::Vector3::Builder getAngular();
  inline void setAngular( ::mrp::geometry::Vector3::Reader value);
  inline  ::mrp::geometry::Vector3::Builder initAngular();
  inline void adoptAngular(::capnp::Orphan< ::mrp::geometry::Vector3>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::Vector3> disownAngular();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Twist::Pipeline {
public:
  typedef Twist Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::geometry::Vector3::Pipeline getLinear();
  inline  ::mrp::geometry::Vector3::Pipeline getAngular();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TwistStamped::Reader {
public:
  typedef TwistStamped Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::mrp::std::Header::Reader getHeader() const;

  inline bool hasTwist() const;
  inline  ::mrp::geometry::Twist::Reader getTwist() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TwistStamped::Builder {
public:
  typedef TwistStamped Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::mrp::std::Header::Builder getHeader();
  inline void setHeader( ::mrp::std::Header::Reader value);
  inline  ::mrp::std::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::mrp::std::Header>&& value);
  inline ::capnp::Orphan< ::mrp::std::Header> disownHeader();

  inline bool hasTwist();
  inline  ::mrp::geometry::Twist::Builder getTwist();
  inline void setTwist( ::mrp::geometry::Twist::Reader value);
  inline  ::mrp::geometry::Twist::Builder initTwist();
  inline void adoptTwist(::capnp::Orphan< ::mrp::geometry::Twist>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::Twist> disownTwist();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TwistStamped::Pipeline {
public:
  typedef TwistStamped Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::std::Header::Pipeline getHeader();
  inline  ::mrp::geometry::Twist::Pipeline getTwist();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TwistWithCovariance::Reader {
public:
  typedef TwistWithCovariance Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasTwist() const;
  inline  ::mrp::geometry::Twist::Reader getTwist() const;

  inline bool hasCovariance() const;
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader getCovariance() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TwistWithCovariance::Builder {
public:
  typedef TwistWithCovariance Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasTwist();
  inline  ::mrp::geometry::Twist::Builder getTwist();
  inline void setTwist( ::mrp::geometry::Twist::Reader value);
  inline  ::mrp::geometry::Twist::Builder initTwist();
  inline void adoptTwist(::capnp::Orphan< ::mrp::geometry::Twist>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::Twist> disownTwist();

  inline bool hasCovariance();
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder getCovariance();
  inline void setCovariance( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setCovariance(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder initCovariance(unsigned int size);
  inline void adoptCovariance(::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> disownCovariance();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TwistWithCovariance::Pipeline {
public:
  typedef TwistWithCovariance Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::geometry::Twist::Pipeline getTwist();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class TwistWithCovarianceStamped::Reader {
public:
  typedef TwistWithCovarianceStamped Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::mrp::std::Header::Reader getHeader() const;

  inline bool hasTwist() const;
  inline  ::mrp::geometry::TwistWithCovariance::Reader getTwist() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class TwistWithCovarianceStamped::Builder {
public:
  typedef TwistWithCovarianceStamped Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::mrp::std::Header::Builder getHeader();
  inline void setHeader( ::mrp::std::Header::Reader value);
  inline  ::mrp::std::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::mrp::std::Header>&& value);
  inline ::capnp::Orphan< ::mrp::std::Header> disownHeader();

  inline bool hasTwist();
  inline  ::mrp::geometry::TwistWithCovariance::Builder getTwist();
  inline void setTwist( ::mrp::geometry::TwistWithCovariance::Reader value);
  inline  ::mrp::geometry::TwistWithCovariance::Builder initTwist();
  inline void adoptTwist(::capnp::Orphan< ::mrp::geometry::TwistWithCovariance>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::TwistWithCovariance> disownTwist();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class TwistWithCovarianceStamped::Pipeline {
public:
  typedef TwistWithCovarianceStamped Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::std::Header::Pipeline getHeader();
  inline  ::mrp::geometry::TwistWithCovariance::Pipeline getTwist();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Vector3::Reader {
public:
  typedef Vector3 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getX() const;

  inline double getY() const;

  inline double getZ() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Vector3::Builder {
public:
  typedef Vector3 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getX();
  inline void setX(double value);

  inline double getY();
  inline void setY(double value);

  inline double getZ();
  inline void setZ(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Vector3::Pipeline {
public:
  typedef Vector3 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Vector3Stamped::Reader {
public:
  typedef Vector3Stamped Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::mrp::std::Header::Reader getHeader() const;

  inline bool hasVector() const;
  inline  ::mrp::geometry::Vector3::Reader getVector() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Vector3Stamped::Builder {
public:
  typedef Vector3Stamped Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::mrp::std::Header::Builder getHeader();
  inline void setHeader( ::mrp::std::Header::Reader value);
  inline  ::mrp::std::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::mrp::std::Header>&& value);
  inline ::capnp::Orphan< ::mrp::std::Header> disownHeader();

  inline bool hasVector();
  inline  ::mrp::geometry::Vector3::Builder getVector();
  inline void setVector( ::mrp::geometry::Vector3::Reader value);
  inline  ::mrp::geometry::Vector3::Builder initVector();
  inline void adoptVector(::capnp::Orphan< ::mrp::geometry::Vector3>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::Vector3> disownVector();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Vector3Stamped::Pipeline {
public:
  typedef Vector3Stamped Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::std::Header::Pipeline getHeader();
  inline  ::mrp::geometry::Vector3::Pipeline getVector();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Wrench::Reader {
public:
  typedef Wrench Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasForce() const;
  inline  ::mrp::geometry::Vector3::Reader getForce() const;

  inline bool hasTorque() const;
  inline  ::mrp::geometry::Vector3::Reader getTorque() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Wrench::Builder {
public:
  typedef Wrench Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasForce();
  inline  ::mrp::geometry::Vector3::Builder getForce();
  inline void setForce( ::mrp::geometry::Vector3::Reader value);
  inline  ::mrp::geometry::Vector3::Builder initForce();
  inline void adoptForce(::capnp::Orphan< ::mrp::geometry::Vector3>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::Vector3> disownForce();

  inline bool hasTorque();
  inline  ::mrp::geometry::Vector3::Builder getTorque();
  inline void setTorque( ::mrp::geometry::Vector3::Reader value);
  inline  ::mrp::geometry::Vector3::Builder initTorque();
  inline void adoptTorque(::capnp::Orphan< ::mrp::geometry::Vector3>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::Vector3> disownTorque();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Wrench::Pipeline {
public:
  typedef Wrench Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::geometry::Vector3::Pipeline getForce();
  inline  ::mrp::geometry::Vector3::Pipeline getTorque();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class WrenchStamped::Reader {
public:
  typedef WrenchStamped Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHeader() const;
  inline  ::mrp::std::Header::Reader getHeader() const;

  inline bool hasWrench() const;
  inline  ::mrp::geometry::Wrench::Reader getWrench() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class WrenchStamped::Builder {
public:
  typedef WrenchStamped Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHeader();
  inline  ::mrp::std::Header::Builder getHeader();
  inline void setHeader( ::mrp::std::Header::Reader value);
  inline  ::mrp::std::Header::Builder initHeader();
  inline void adoptHeader(::capnp::Orphan< ::mrp::std::Header>&& value);
  inline ::capnp::Orphan< ::mrp::std::Header> disownHeader();

  inline bool hasWrench();
  inline  ::mrp::geometry::Wrench::Builder getWrench();
  inline void setWrench( ::mrp::geometry::Wrench::Reader value);
  inline  ::mrp::geometry::Wrench::Builder initWrench();
  inline void adoptWrench(::capnp::Orphan< ::mrp::geometry::Wrench>&& value);
  inline ::capnp::Orphan< ::mrp::geometry::Wrench> disownWrench();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class WrenchStamped::Pipeline {
public:
  typedef WrenchStamped Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::mrp::std::Header::Pipeline getHeader();
  inline  ::mrp::geometry::Wrench::Pipeline getWrench();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline bool Accel::Reader::hasLinear() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Accel::Builder::hasLinear() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::Vector3::Reader Accel::Reader::getLinear() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::Vector3::Builder Accel::Builder::getLinear() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::Vector3::Pipeline Accel::Pipeline::getLinear() {
  return  ::mrp::geometry::Vector3::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Accel::Builder::setLinear( ::mrp::geometry::Vector3::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::Vector3::Builder Accel::Builder::initLinear() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Accel::Builder::adoptLinear(
    ::capnp::Orphan< ::mrp::geometry::Vector3>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::Vector3> Accel::Builder::disownLinear() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Accel::Reader::hasAngular() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Accel::Builder::hasAngular() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::Vector3::Reader Accel::Reader::getAngular() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::Vector3::Builder Accel::Builder::getAngular() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::Vector3::Pipeline Accel::Pipeline::getAngular() {
  return  ::mrp::geometry::Vector3::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Accel::Builder::setAngular( ::mrp::geometry::Vector3::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::Vector3::Builder Accel::Builder::initAngular() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Accel::Builder::adoptAngular(
    ::capnp::Orphan< ::mrp::geometry::Vector3>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::Vector3> Accel::Builder::disownAngular() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool AccelStamped::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AccelStamped::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::std::Header::Reader AccelStamped::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::std::Header::Builder AccelStamped::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::std::Header::Pipeline AccelStamped::Pipeline::getHeader() {
  return  ::mrp::std::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void AccelStamped::Builder::setHeader( ::mrp::std::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::std::Header::Builder AccelStamped::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AccelStamped::Builder::adoptHeader(
    ::capnp::Orphan< ::mrp::std::Header>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::std::Header> AccelStamped::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool AccelStamped::Reader::hasAccel() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool AccelStamped::Builder::hasAccel() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::Accel::Reader AccelStamped::Reader::getAccel() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Accel>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::Accel::Builder AccelStamped::Builder::getAccel() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Accel>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::Accel::Pipeline AccelStamped::Pipeline::getAccel() {
  return  ::mrp::geometry::Accel::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void AccelStamped::Builder::setAccel( ::mrp::geometry::Accel::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Accel>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::Accel::Builder AccelStamped::Builder::initAccel() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Accel>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void AccelStamped::Builder::adoptAccel(
    ::capnp::Orphan< ::mrp::geometry::Accel>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Accel>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::Accel> AccelStamped::Builder::disownAccel() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Accel>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool AccelWithCovariance::Reader::hasAccel() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AccelWithCovariance::Builder::hasAccel() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::Accel::Reader AccelWithCovariance::Reader::getAccel() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Accel>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::Accel::Builder AccelWithCovariance::Builder::getAccel() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Accel>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::Accel::Pipeline AccelWithCovariance::Pipeline::getAccel() {
  return  ::mrp::geometry::Accel::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void AccelWithCovariance::Builder::setAccel( ::mrp::geometry::Accel::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Accel>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::Accel::Builder AccelWithCovariance::Builder::initAccel() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Accel>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AccelWithCovariance::Builder::adoptAccel(
    ::capnp::Orphan< ::mrp::geometry::Accel>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Accel>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::Accel> AccelWithCovariance::Builder::disownAccel() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Accel>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool AccelWithCovariance::Reader::hasCovariance() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool AccelWithCovariance::Builder::hasCovariance() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader AccelWithCovariance::Reader::getCovariance() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder AccelWithCovariance::Builder::getCovariance() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void AccelWithCovariance::Builder::setCovariance( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void AccelWithCovariance::Builder::setCovariance(::kj::ArrayPtr<const double> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder AccelWithCovariance::Builder::initCovariance(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void AccelWithCovariance::Builder::adoptCovariance(
    ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> AccelWithCovariance::Builder::disownCovariance() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool AccelWithCovarianceStamped::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool AccelWithCovarianceStamped::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::std::Header::Reader AccelWithCovarianceStamped::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::std::Header::Builder AccelWithCovarianceStamped::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::std::Header::Pipeline AccelWithCovarianceStamped::Pipeline::getHeader() {
  return  ::mrp::std::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void AccelWithCovarianceStamped::Builder::setHeader( ::mrp::std::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::std::Header::Builder AccelWithCovarianceStamped::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void AccelWithCovarianceStamped::Builder::adoptHeader(
    ::capnp::Orphan< ::mrp::std::Header>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::std::Header> AccelWithCovarianceStamped::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool AccelWithCovarianceStamped::Reader::hasAccel() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool AccelWithCovarianceStamped::Builder::hasAccel() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::AccelWithCovariance::Reader AccelWithCovarianceStamped::Reader::getAccel() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::AccelWithCovariance>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::AccelWithCovariance::Builder AccelWithCovarianceStamped::Builder::getAccel() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::AccelWithCovariance>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::AccelWithCovariance::Pipeline AccelWithCovarianceStamped::Pipeline::getAccel() {
  return  ::mrp::geometry::AccelWithCovariance::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void AccelWithCovarianceStamped::Builder::setAccel( ::mrp::geometry::AccelWithCovariance::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::AccelWithCovariance>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::AccelWithCovariance::Builder AccelWithCovarianceStamped::Builder::initAccel() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::AccelWithCovariance>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void AccelWithCovarianceStamped::Builder::adoptAccel(
    ::capnp::Orphan< ::mrp::geometry::AccelWithCovariance>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::AccelWithCovariance>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::AccelWithCovariance> AccelWithCovarianceStamped::Builder::disownAccel() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::AccelWithCovariance>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline double Inertia::Reader::getM() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Inertia::Builder::getM() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Inertia::Builder::setM(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Inertia::Reader::hasCom() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Inertia::Builder::hasCom() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::Vector3::Reader Inertia::Reader::getCom() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::Vector3::Builder Inertia::Builder::getCom() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::Vector3::Pipeline Inertia::Pipeline::getCom() {
  return  ::mrp::geometry::Vector3::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Inertia::Builder::setCom( ::mrp::geometry::Vector3::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::Vector3::Builder Inertia::Builder::initCom() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Inertia::Builder::adoptCom(
    ::capnp::Orphan< ::mrp::geometry::Vector3>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::Vector3> Inertia::Builder::disownCom() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double Inertia::Reader::getIxx() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Inertia::Builder::getIxx() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Inertia::Builder::setIxx(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline double Inertia::Reader::getIxy() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline double Inertia::Builder::getIxy() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Inertia::Builder::setIxy(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline double Inertia::Reader::getIxz() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline double Inertia::Builder::getIxz() {
  return _builder.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Inertia::Builder::setIxz(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline double Inertia::Reader::getIyy() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline double Inertia::Builder::getIyy() {
  return _builder.getDataField<double>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void Inertia::Builder::setIyy(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline double Inertia::Reader::getIyz() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}

inline double Inertia::Builder::getIyz() {
  return _builder.getDataField<double>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS);
}
inline void Inertia::Builder::setIyz(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<5>() * ::capnp::ELEMENTS, value);
}

inline double Inertia::Reader::getIzz() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}

inline double Inertia::Builder::getIzz() {
  return _builder.getDataField<double>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS);
}
inline void Inertia::Builder::setIzz(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<6>() * ::capnp::ELEMENTS, value);
}

inline bool InertiaStamped::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool InertiaStamped::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::std::Header::Reader InertiaStamped::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::std::Header::Builder InertiaStamped::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::std::Header::Pipeline InertiaStamped::Pipeline::getHeader() {
  return  ::mrp::std::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void InertiaStamped::Builder::setHeader( ::mrp::std::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::std::Header::Builder InertiaStamped::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void InertiaStamped::Builder::adoptHeader(
    ::capnp::Orphan< ::mrp::std::Header>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::std::Header> InertiaStamped::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool InertiaStamped::Reader::hasInertia() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool InertiaStamped::Builder::hasInertia() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::Inertia::Reader InertiaStamped::Reader::getInertia() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Inertia>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::Inertia::Builder InertiaStamped::Builder::getInertia() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Inertia>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::Inertia::Pipeline InertiaStamped::Pipeline::getInertia() {
  return  ::mrp::geometry::Inertia::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void InertiaStamped::Builder::setInertia( ::mrp::geometry::Inertia::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Inertia>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::Inertia::Builder InertiaStamped::Builder::initInertia() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Inertia>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void InertiaStamped::Builder::adoptInertia(
    ::capnp::Orphan< ::mrp::geometry::Inertia>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Inertia>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::Inertia> InertiaStamped::Builder::disownInertia() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Inertia>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline double Point::Reader::getX() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Point::Builder::getX() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Point::Builder::setX(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Point::Reader::getY() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Point::Builder::getY() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Point::Builder::setY(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline double Point::Reader::getZ() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline double Point::Builder::getZ() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Point::Builder::setZ(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float Point32::Reader::getX() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Point32::Builder::getX() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Point32::Builder::setX(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Point32::Reader::getY() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Point32::Builder::getY() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Point32::Builder::setY(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float Point32::Reader::getZ() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float Point32::Builder::getZ() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Point32::Builder::setZ(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool PointStamped::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PointStamped::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::std::Header::Reader PointStamped::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::std::Header::Builder PointStamped::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::std::Header::Pipeline PointStamped::Pipeline::getHeader() {
  return  ::mrp::std::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void PointStamped::Builder::setHeader( ::mrp::std::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::std::Header::Builder PointStamped::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PointStamped::Builder::adoptHeader(
    ::capnp::Orphan< ::mrp::std::Header>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::std::Header> PointStamped::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool PointStamped::Reader::hasPoint() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool PointStamped::Builder::hasPoint() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::Point::Reader PointStamped::Reader::getPoint() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Point>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::Point::Builder PointStamped::Builder::getPoint() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Point>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::Point::Pipeline PointStamped::Pipeline::getPoint() {
  return  ::mrp::geometry::Point::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void PointStamped::Builder::setPoint( ::mrp::geometry::Point::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Point>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::Point::Builder PointStamped::Builder::initPoint() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Point>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void PointStamped::Builder::adoptPoint(
    ::capnp::Orphan< ::mrp::geometry::Point>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Point>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::Point> PointStamped::Builder::disownPoint() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Point>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Polygon::Reader::hasPoints() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Polygon::Builder::hasPoints() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mrp::geometry::Point32,  ::capnp::Kind::STRUCT>::Reader Polygon::Reader::getPoints() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mrp::geometry::Point32,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mrp::geometry::Point32,  ::capnp::Kind::STRUCT>::Builder Polygon::Builder::getPoints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mrp::geometry::Point32,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Polygon::Builder::setPoints( ::capnp::List< ::mrp::geometry::Point32,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mrp::geometry::Point32,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mrp::geometry::Point32,  ::capnp::Kind::STRUCT>::Builder Polygon::Builder::initPoints(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mrp::geometry::Point32,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Polygon::Builder::adoptPoints(
    ::capnp::Orphan< ::capnp::List< ::mrp::geometry::Point32,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mrp::geometry::Point32,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mrp::geometry::Point32,  ::capnp::Kind::STRUCT>> Polygon::Builder::disownPoints() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mrp::geometry::Point32,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool PolygonStamped::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PolygonStamped::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::std::Header::Reader PolygonStamped::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::std::Header::Builder PolygonStamped::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::std::Header::Pipeline PolygonStamped::Pipeline::getHeader() {
  return  ::mrp::std::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void PolygonStamped::Builder::setHeader( ::mrp::std::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::std::Header::Builder PolygonStamped::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PolygonStamped::Builder::adoptHeader(
    ::capnp::Orphan< ::mrp::std::Header>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::std::Header> PolygonStamped::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool PolygonStamped::Reader::hasPolygon() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool PolygonStamped::Builder::hasPolygon() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::Polygon::Reader PolygonStamped::Reader::getPolygon() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Polygon>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::Polygon::Builder PolygonStamped::Builder::getPolygon() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Polygon>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::Polygon::Pipeline PolygonStamped::Pipeline::getPolygon() {
  return  ::mrp::geometry::Polygon::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void PolygonStamped::Builder::setPolygon( ::mrp::geometry::Polygon::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Polygon>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::Polygon::Builder PolygonStamped::Builder::initPolygon() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Polygon>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void PolygonStamped::Builder::adoptPolygon(
    ::capnp::Orphan< ::mrp::geometry::Polygon>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Polygon>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::Polygon> PolygonStamped::Builder::disownPolygon() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Polygon>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Pose::Reader::hasPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Pose::Builder::hasPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::Point::Reader Pose::Reader::getPosition() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Point>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::Point::Builder Pose::Builder::getPosition() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Point>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::Point::Pipeline Pose::Pipeline::getPosition() {
  return  ::mrp::geometry::Point::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Pose::Builder::setPosition( ::mrp::geometry::Point::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Point>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::Point::Builder Pose::Builder::initPosition() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Point>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Pose::Builder::adoptPosition(
    ::capnp::Orphan< ::mrp::geometry::Point>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Point>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::Point> Pose::Builder::disownPosition() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Point>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Pose::Reader::hasOrientation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Pose::Builder::hasOrientation() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::Quaternion::Reader Pose::Reader::getOrientation() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Quaternion>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::Quaternion::Builder Pose::Builder::getOrientation() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Quaternion>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::Quaternion::Pipeline Pose::Pipeline::getOrientation() {
  return  ::mrp::geometry::Quaternion::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Pose::Builder::setOrientation( ::mrp::geometry::Quaternion::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Quaternion>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::Quaternion::Builder Pose::Builder::initOrientation() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Quaternion>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Pose::Builder::adoptOrientation(
    ::capnp::Orphan< ::mrp::geometry::Quaternion>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Quaternion>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::Quaternion> Pose::Builder::disownOrientation() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Quaternion>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline double Pose2D::Reader::getX() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Pose2D::Builder::getX() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Pose2D::Builder::setX(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Pose2D::Reader::getY() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Pose2D::Builder::getY() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Pose2D::Builder::setY(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline double Pose2D::Reader::getTheta() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline double Pose2D::Builder::getTheta() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Pose2D::Builder::setTheta(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool PoseArray::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PoseArray::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::std::Header::Reader PoseArray::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::std::Header::Builder PoseArray::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::std::Header::Pipeline PoseArray::Pipeline::getHeader() {
  return  ::mrp::std::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void PoseArray::Builder::setHeader( ::mrp::std::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::std::Header::Builder PoseArray::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PoseArray::Builder::adoptHeader(
    ::capnp::Orphan< ::mrp::std::Header>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::std::Header> PoseArray::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool PoseArray::Reader::hasPoses() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool PoseArray::Builder::hasPoses() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::mrp::geometry::Pose,  ::capnp::Kind::STRUCT>::Reader PoseArray::Reader::getPoses() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mrp::geometry::Pose,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::mrp::geometry::Pose,  ::capnp::Kind::STRUCT>::Builder PoseArray::Builder::getPoses() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mrp::geometry::Pose,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void PoseArray::Builder::setPoses( ::capnp::List< ::mrp::geometry::Pose,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mrp::geometry::Pose,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::mrp::geometry::Pose,  ::capnp::Kind::STRUCT>::Builder PoseArray::Builder::initPoses(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mrp::geometry::Pose,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void PoseArray::Builder::adoptPoses(
    ::capnp::Orphan< ::capnp::List< ::mrp::geometry::Pose,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::mrp::geometry::Pose,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::mrp::geometry::Pose,  ::capnp::Kind::STRUCT>> PoseArray::Builder::disownPoses() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::mrp::geometry::Pose,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool PoseStamped::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PoseStamped::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::std::Header::Reader PoseStamped::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::std::Header::Builder PoseStamped::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::std::Header::Pipeline PoseStamped::Pipeline::getHeader() {
  return  ::mrp::std::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void PoseStamped::Builder::setHeader( ::mrp::std::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::std::Header::Builder PoseStamped::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PoseStamped::Builder::adoptHeader(
    ::capnp::Orphan< ::mrp::std::Header>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::std::Header> PoseStamped::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool PoseStamped::Reader::hasPose() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool PoseStamped::Builder::hasPose() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::Pose::Reader PoseStamped::Reader::getPose() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Pose>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::Pose::Builder PoseStamped::Builder::getPose() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Pose>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::Pose::Pipeline PoseStamped::Pipeline::getPose() {
  return  ::mrp::geometry::Pose::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void PoseStamped::Builder::setPose( ::mrp::geometry::Pose::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Pose>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::Pose::Builder PoseStamped::Builder::initPose() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Pose>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void PoseStamped::Builder::adoptPose(
    ::capnp::Orphan< ::mrp::geometry::Pose>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Pose>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::Pose> PoseStamped::Builder::disownPose() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Pose>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool PoseWithCovariance::Reader::hasPose() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PoseWithCovariance::Builder::hasPose() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::Pose::Reader PoseWithCovariance::Reader::getPose() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Pose>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::Pose::Builder PoseWithCovariance::Builder::getPose() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Pose>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::Pose::Pipeline PoseWithCovariance::Pipeline::getPose() {
  return  ::mrp::geometry::Pose::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void PoseWithCovariance::Builder::setPose( ::mrp::geometry::Pose::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Pose>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::Pose::Builder PoseWithCovariance::Builder::initPose() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Pose>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PoseWithCovariance::Builder::adoptPose(
    ::capnp::Orphan< ::mrp::geometry::Pose>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Pose>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::Pose> PoseWithCovariance::Builder::disownPose() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Pose>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool PoseWithCovariance::Reader::hasCovariance() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool PoseWithCovariance::Builder::hasCovariance() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader PoseWithCovariance::Reader::getCovariance() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder PoseWithCovariance::Builder::getCovariance() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void PoseWithCovariance::Builder::setCovariance( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void PoseWithCovariance::Builder::setCovariance(::kj::ArrayPtr<const double> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder PoseWithCovariance::Builder::initCovariance(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void PoseWithCovariance::Builder::adoptCovariance(
    ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> PoseWithCovariance::Builder::disownCovariance() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool PoseWithCovarianceStamped::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool PoseWithCovarianceStamped::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::std::Header::Reader PoseWithCovarianceStamped::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::std::Header::Builder PoseWithCovarianceStamped::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::std::Header::Pipeline PoseWithCovarianceStamped::Pipeline::getHeader() {
  return  ::mrp::std::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void PoseWithCovarianceStamped::Builder::setHeader( ::mrp::std::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::std::Header::Builder PoseWithCovarianceStamped::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void PoseWithCovarianceStamped::Builder::adoptHeader(
    ::capnp::Orphan< ::mrp::std::Header>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::std::Header> PoseWithCovarianceStamped::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool PoseWithCovarianceStamped::Reader::hasPose() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool PoseWithCovarianceStamped::Builder::hasPose() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::PoseWithCovariance::Reader PoseWithCovarianceStamped::Reader::getPose() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::PoseWithCovariance>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::PoseWithCovariance::Builder PoseWithCovarianceStamped::Builder::getPose() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::PoseWithCovariance>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::PoseWithCovariance::Pipeline PoseWithCovarianceStamped::Pipeline::getPose() {
  return  ::mrp::geometry::PoseWithCovariance::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void PoseWithCovarianceStamped::Builder::setPose( ::mrp::geometry::PoseWithCovariance::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::PoseWithCovariance>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::PoseWithCovariance::Builder PoseWithCovarianceStamped::Builder::initPose() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::PoseWithCovariance>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void PoseWithCovarianceStamped::Builder::adoptPose(
    ::capnp::Orphan< ::mrp::geometry::PoseWithCovariance>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::PoseWithCovariance>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::PoseWithCovariance> PoseWithCovarianceStamped::Builder::disownPose() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::PoseWithCovariance>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline double Quaternion::Reader::getX() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Quaternion::Builder::getX() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Quaternion::Builder::setX(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Quaternion::Reader::getY() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Quaternion::Builder::getY() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Quaternion::Builder::setY(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline double Quaternion::Reader::getZ() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline double Quaternion::Builder::getZ() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Quaternion::Builder::setZ(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline double Quaternion::Reader::getW() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline double Quaternion::Builder::getW() {
  return _builder.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Quaternion::Builder::setW(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool QuaternionStamped::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool QuaternionStamped::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::std::Header::Reader QuaternionStamped::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::std::Header::Builder QuaternionStamped::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::std::Header::Pipeline QuaternionStamped::Pipeline::getHeader() {
  return  ::mrp::std::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void QuaternionStamped::Builder::setHeader( ::mrp::std::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::std::Header::Builder QuaternionStamped::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void QuaternionStamped::Builder::adoptHeader(
    ::capnp::Orphan< ::mrp::std::Header>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::std::Header> QuaternionStamped::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool QuaternionStamped::Reader::hasQuaternion() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool QuaternionStamped::Builder::hasQuaternion() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::Quaternion::Reader QuaternionStamped::Reader::getQuaternion() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Quaternion>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::Quaternion::Builder QuaternionStamped::Builder::getQuaternion() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Quaternion>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::Quaternion::Pipeline QuaternionStamped::Pipeline::getQuaternion() {
  return  ::mrp::geometry::Quaternion::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void QuaternionStamped::Builder::setQuaternion( ::mrp::geometry::Quaternion::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Quaternion>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::Quaternion::Builder QuaternionStamped::Builder::initQuaternion() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Quaternion>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void QuaternionStamped::Builder::adoptQuaternion(
    ::capnp::Orphan< ::mrp::geometry::Quaternion>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Quaternion>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::Quaternion> QuaternionStamped::Builder::disownQuaternion() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Quaternion>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Transform::Reader::hasTranslation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Transform::Builder::hasTranslation() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::Vector3::Reader Transform::Reader::getTranslation() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::Vector3::Builder Transform::Builder::getTranslation() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::Vector3::Pipeline Transform::Pipeline::getTranslation() {
  return  ::mrp::geometry::Vector3::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Transform::Builder::setTranslation( ::mrp::geometry::Vector3::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::Vector3::Builder Transform::Builder::initTranslation() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Transform::Builder::adoptTranslation(
    ::capnp::Orphan< ::mrp::geometry::Vector3>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::Vector3> Transform::Builder::disownTranslation() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Transform::Reader::hasRotation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Transform::Builder::hasRotation() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::Quaternion::Reader Transform::Reader::getRotation() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Quaternion>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::Quaternion::Builder Transform::Builder::getRotation() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Quaternion>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::Quaternion::Pipeline Transform::Pipeline::getRotation() {
  return  ::mrp::geometry::Quaternion::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Transform::Builder::setRotation( ::mrp::geometry::Quaternion::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Quaternion>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::Quaternion::Builder Transform::Builder::initRotation() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Quaternion>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Transform::Builder::adoptRotation(
    ::capnp::Orphan< ::mrp::geometry::Quaternion>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Quaternion>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::Quaternion> Transform::Builder::disownRotation() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Quaternion>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TransformStamped::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TransformStamped::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::std::Header::Reader TransformStamped::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::std::Header::Builder TransformStamped::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::std::Header::Pipeline TransformStamped::Pipeline::getHeader() {
  return  ::mrp::std::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void TransformStamped::Builder::setHeader( ::mrp::std::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::std::Header::Builder TransformStamped::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TransformStamped::Builder::adoptHeader(
    ::capnp::Orphan< ::mrp::std::Header>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::std::Header> TransformStamped::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TransformStamped::Reader::hasChildFrameId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TransformStamped::Builder::hasChildFrameId() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader TransformStamped::Reader::getChildFrameId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder TransformStamped::Builder::getChildFrameId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TransformStamped::Builder::setChildFrameId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder TransformStamped::Builder::initChildFrameId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TransformStamped::Builder::adoptChildFrameId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> TransformStamped::Builder::disownChildFrameId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TransformStamped::Reader::hasTransform() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool TransformStamped::Builder::hasTransform() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::Transform::Reader TransformStamped::Reader::getTransform() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Transform>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::Transform::Builder TransformStamped::Builder::getTransform() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Transform>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::Transform::Pipeline TransformStamped::Pipeline::getTransform() {
  return  ::mrp::geometry::Transform::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void TransformStamped::Builder::setTransform( ::mrp::geometry::Transform::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Transform>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::Transform::Builder TransformStamped::Builder::initTransform() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Transform>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void TransformStamped::Builder::adoptTransform(
    ::capnp::Orphan< ::mrp::geometry::Transform>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Transform>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::Transform> TransformStamped::Builder::disownTransform() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Transform>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Twist::Reader::hasLinear() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Twist::Builder::hasLinear() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::Vector3::Reader Twist::Reader::getLinear() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::Vector3::Builder Twist::Builder::getLinear() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::Vector3::Pipeline Twist::Pipeline::getLinear() {
  return  ::mrp::geometry::Vector3::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Twist::Builder::setLinear( ::mrp::geometry::Vector3::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::Vector3::Builder Twist::Builder::initLinear() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Twist::Builder::adoptLinear(
    ::capnp::Orphan< ::mrp::geometry::Vector3>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::Vector3> Twist::Builder::disownLinear() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Twist::Reader::hasAngular() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Twist::Builder::hasAngular() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::Vector3::Reader Twist::Reader::getAngular() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::Vector3::Builder Twist::Builder::getAngular() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::Vector3::Pipeline Twist::Pipeline::getAngular() {
  return  ::mrp::geometry::Vector3::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Twist::Builder::setAngular( ::mrp::geometry::Vector3::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::Vector3::Builder Twist::Builder::initAngular() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Twist::Builder::adoptAngular(
    ::capnp::Orphan< ::mrp::geometry::Vector3>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::Vector3> Twist::Builder::disownAngular() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TwistStamped::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TwistStamped::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::std::Header::Reader TwistStamped::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::std::Header::Builder TwistStamped::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::std::Header::Pipeline TwistStamped::Pipeline::getHeader() {
  return  ::mrp::std::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void TwistStamped::Builder::setHeader( ::mrp::std::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::std::Header::Builder TwistStamped::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TwistStamped::Builder::adoptHeader(
    ::capnp::Orphan< ::mrp::std::Header>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::std::Header> TwistStamped::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TwistStamped::Reader::hasTwist() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TwistStamped::Builder::hasTwist() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::Twist::Reader TwistStamped::Reader::getTwist() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Twist>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::Twist::Builder TwistStamped::Builder::getTwist() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Twist>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::Twist::Pipeline TwistStamped::Pipeline::getTwist() {
  return  ::mrp::geometry::Twist::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void TwistStamped::Builder::setTwist( ::mrp::geometry::Twist::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Twist>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::Twist::Builder TwistStamped::Builder::initTwist() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Twist>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TwistStamped::Builder::adoptTwist(
    ::capnp::Orphan< ::mrp::geometry::Twist>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Twist>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::Twist> TwistStamped::Builder::disownTwist() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Twist>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TwistWithCovariance::Reader::hasTwist() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TwistWithCovariance::Builder::hasTwist() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::Twist::Reader TwistWithCovariance::Reader::getTwist() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Twist>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::Twist::Builder TwistWithCovariance::Builder::getTwist() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Twist>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::Twist::Pipeline TwistWithCovariance::Pipeline::getTwist() {
  return  ::mrp::geometry::Twist::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void TwistWithCovariance::Builder::setTwist( ::mrp::geometry::Twist::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Twist>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::Twist::Builder TwistWithCovariance::Builder::initTwist() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Twist>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TwistWithCovariance::Builder::adoptTwist(
    ::capnp::Orphan< ::mrp::geometry::Twist>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Twist>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::Twist> TwistWithCovariance::Builder::disownTwist() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Twist>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TwistWithCovariance::Reader::hasCovariance() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TwistWithCovariance::Builder::hasCovariance() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader TwistWithCovariance::Reader::getCovariance() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder TwistWithCovariance::Builder::getCovariance() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TwistWithCovariance::Builder::setCovariance( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void TwistWithCovariance::Builder::setCovariance(::kj::ArrayPtr<const double> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder TwistWithCovariance::Builder::initCovariance(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void TwistWithCovariance::Builder::adoptCovariance(
    ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> TwistWithCovariance::Builder::disownCovariance() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool TwistWithCovarianceStamped::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool TwistWithCovarianceStamped::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::std::Header::Reader TwistWithCovarianceStamped::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::std::Header::Builder TwistWithCovarianceStamped::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::std::Header::Pipeline TwistWithCovarianceStamped::Pipeline::getHeader() {
  return  ::mrp::std::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void TwistWithCovarianceStamped::Builder::setHeader( ::mrp::std::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::std::Header::Builder TwistWithCovarianceStamped::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void TwistWithCovarianceStamped::Builder::adoptHeader(
    ::capnp::Orphan< ::mrp::std::Header>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::std::Header> TwistWithCovarianceStamped::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool TwistWithCovarianceStamped::Reader::hasTwist() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool TwistWithCovarianceStamped::Builder::hasTwist() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::TwistWithCovariance::Reader TwistWithCovarianceStamped::Reader::getTwist() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::TwistWithCovariance>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::TwistWithCovariance::Builder TwistWithCovarianceStamped::Builder::getTwist() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::TwistWithCovariance>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::TwistWithCovariance::Pipeline TwistWithCovarianceStamped::Pipeline::getTwist() {
  return  ::mrp::geometry::TwistWithCovariance::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void TwistWithCovarianceStamped::Builder::setTwist( ::mrp::geometry::TwistWithCovariance::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::TwistWithCovariance>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::TwistWithCovariance::Builder TwistWithCovarianceStamped::Builder::initTwist() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::TwistWithCovariance>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void TwistWithCovarianceStamped::Builder::adoptTwist(
    ::capnp::Orphan< ::mrp::geometry::TwistWithCovariance>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::TwistWithCovariance>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::TwistWithCovariance> TwistWithCovarianceStamped::Builder::disownTwist() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::TwistWithCovariance>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline double Vector3::Reader::getX() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Vector3::Builder::getX() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Vector3::Builder::setX(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Vector3::Reader::getY() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Vector3::Builder::getY() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Vector3::Builder::setY(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline double Vector3::Reader::getZ() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline double Vector3::Builder::getZ() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Vector3::Builder::setZ(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Vector3Stamped::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Vector3Stamped::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::std::Header::Reader Vector3Stamped::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::std::Header::Builder Vector3Stamped::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::std::Header::Pipeline Vector3Stamped::Pipeline::getHeader() {
  return  ::mrp::std::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Vector3Stamped::Builder::setHeader( ::mrp::std::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::std::Header::Builder Vector3Stamped::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Vector3Stamped::Builder::adoptHeader(
    ::capnp::Orphan< ::mrp::std::Header>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::std::Header> Vector3Stamped::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Vector3Stamped::Reader::hasVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Vector3Stamped::Builder::hasVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::Vector3::Reader Vector3Stamped::Reader::getVector() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::Vector3::Builder Vector3Stamped::Builder::getVector() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::Vector3::Pipeline Vector3Stamped::Pipeline::getVector() {
  return  ::mrp::geometry::Vector3::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Vector3Stamped::Builder::setVector( ::mrp::geometry::Vector3::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::Vector3::Builder Vector3Stamped::Builder::initVector() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Vector3Stamped::Builder::adoptVector(
    ::capnp::Orphan< ::mrp::geometry::Vector3>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::Vector3> Vector3Stamped::Builder::disownVector() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Wrench::Reader::hasForce() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Wrench::Builder::hasForce() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::Vector3::Reader Wrench::Reader::getForce() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::Vector3::Builder Wrench::Builder::getForce() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::Vector3::Pipeline Wrench::Pipeline::getForce() {
  return  ::mrp::geometry::Vector3::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Wrench::Builder::setForce( ::mrp::geometry::Vector3::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::Vector3::Builder Wrench::Builder::initForce() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Wrench::Builder::adoptForce(
    ::capnp::Orphan< ::mrp::geometry::Vector3>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::Vector3> Wrench::Builder::disownForce() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Wrench::Reader::hasTorque() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Wrench::Builder::hasTorque() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::Vector3::Reader Wrench::Reader::getTorque() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::Vector3::Builder Wrench::Builder::getTorque() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::Vector3::Pipeline Wrench::Pipeline::getTorque() {
  return  ::mrp::geometry::Vector3::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Wrench::Builder::setTorque( ::mrp::geometry::Vector3::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::Vector3::Builder Wrench::Builder::initTorque() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Wrench::Builder::adoptTorque(
    ::capnp::Orphan< ::mrp::geometry::Vector3>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::Vector3> Wrench::Builder::disownTorque() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Vector3>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool WrenchStamped::Reader::hasHeader() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool WrenchStamped::Builder::hasHeader() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::std::Header::Reader WrenchStamped::Reader::getHeader() const {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::mrp::std::Header::Builder WrenchStamped::Builder::getHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::std::Header::Pipeline WrenchStamped::Pipeline::getHeader() {
  return  ::mrp::std::Header::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void WrenchStamped::Builder::setHeader( ::mrp::std::Header::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::mrp::std::Header::Builder WrenchStamped::Builder::initHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void WrenchStamped::Builder::adoptHeader(
    ::capnp::Orphan< ::mrp::std::Header>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::std::Header>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::std::Header> WrenchStamped::Builder::disownHeader() {
  return ::capnp::_::PointerHelpers< ::mrp::std::Header>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool WrenchStamped::Reader::hasWrench() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool WrenchStamped::Builder::hasWrench() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::mrp::geometry::Wrench::Reader WrenchStamped::Reader::getWrench() const {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Wrench>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::mrp::geometry::Wrench::Builder WrenchStamped::Builder::getWrench() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Wrench>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::mrp::geometry::Wrench::Pipeline WrenchStamped::Pipeline::getWrench() {
  return  ::mrp::geometry::Wrench::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void WrenchStamped::Builder::setWrench( ::mrp::geometry::Wrench::Reader value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Wrench>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::mrp::geometry::Wrench::Builder WrenchStamped::Builder::initWrench() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Wrench>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void WrenchStamped::Builder::adoptWrench(
    ::capnp::Orphan< ::mrp::geometry::Wrench>&& value) {
  ::capnp::_::PointerHelpers< ::mrp::geometry::Wrench>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::mrp::geometry::Wrench> WrenchStamped::Builder::disownWrench() {
  return ::capnp::_::PointerHelpers< ::mrp::geometry::Wrench>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

}  // namespace
}  // namespace

CAPNP_END_HEADER

